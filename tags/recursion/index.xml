<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Recursion on Code talks</title><link>/tags/recursion/</link><description>Recent content in Recursion on Code talks</description><generator>Hugo</generator><language>zh-CN</language><copyright> Copyright © 2025 Leo Douglas</copyright><lastBuildDate>Fri, 18 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="/tags/recursion/index.xml" rel="self" type="application/rss+xml"/><item><title>深入探讨 Go 语言的深度递归问题</title><link>/post/deep-dive-into-deeply-recursive-go/</link><pubDate>Fri, 18 Jul 2025 00:00:00 +0000</pubDate><guid>/post/deep-dive-into-deeply-recursive-go/</guid><description>&lt;p>本文翻译自 &lt;a href="https://mattermost.com/blog/a-deep-dive-into-deeply-recursive-go/">A deep dive into deeply recursive Go&lt;/a>，版权归原作者所有。&lt;/p>
&lt;p>在我们 &lt;a href="https://mattermost.com/blog/year-of-security-fixes-in-go/">之前关于 Go 安全性的博客文章&lt;/a> 中，我们写到了 2024 年修复的安全问题。其中一个要点与 9 月份发布的 Go 1.22.7 和 1.23.1 安全版本有关，该版本包含了对三个拒绝服务漏洞的修复。栈耗尽是这三个问题的根本原因，在没有明确以防御性方式编写的代码中极其常见。特别是在 Go 中，由于运行时处理栈耗尽的方式，栈耗尽比大多数内存安全语言更加危险。当栈耗尽发生时，崩溃是不可避免的。&lt;/p>
&lt;p>需要进一步调查深度递归在 Go 中为何如此糟糕的机制、通常如何最终编写出深度递归的 Go 代码，以及可以采取什么措施来缓解栈耗尽问题。&lt;/p>
&lt;h2 id="定义深度递归">定义深度递归&lt;/h2>
&lt;p>有些问题本质上是递归的。这并不是说这些问题不能用迭代方式解决，而是递归解决方案更直观，通常也更易读。一个简单的例子是斐波那契数列，其定义本身就是递归的：数列中的每个元素都是前两个元素的和。编写一个打印数列的迭代 Go 程序很容易，但递归实现更直观，因为它直接映射到定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Fibonacci 打印斐波那契数列 1, 1, 2, 3, 5, ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Fibonacci&lt;/span>(&lt;span style="color:#a6e22e">f&lt;/span> &lt;span style="color:#f92672">...&lt;/span>&lt;span style="color:#66d9ef">uint64&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#66d9ef">uint64&lt;/span> = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">f&lt;/span>) &amp;gt; &lt;span style="color:#ae81ff">1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">next&lt;/span> = &lt;span style="color:#a6e22e">f&lt;/span>[len(&lt;span style="color:#a6e22e">f&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>[len(&lt;span style="color:#a6e22e">f&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d, &amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">next&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Fibonacci&lt;/span>(append(&lt;span style="color:#a6e22e">f&lt;/span>, &lt;span style="color:#a6e22e">next&lt;/span>)&lt;span style="color:#f92672">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个函数是 &lt;strong>无限&lt;/strong> 递归的一个例子：它会一直打印斐波那契数列中的数字直到永远——或者直到某个外部力量阻止它。这也是一个 &lt;strong>尾递归&lt;/strong> 函数的例子，其中递归步骤是函数体中的最后一条语句。这样的函数很容易转换为迭代形式，甚至可以通过编译器在称为尾调用优化（TCO）的过程中自动转换。不幸的是，&lt;a href="https://github.com/golang/go/issues/22624">Go 不支持 TCO&lt;/a>，这意味着递归不会被优化掉，导致栈在数列的每一步都会增长。&lt;/p>
&lt;h3 id="栈和堆的说明">栈和堆的说明&lt;/h3>
&lt;p>Go 程序可以访问两种类型的内存：栈和堆，就像一般的计算机程序一样。一个只使用局部变量和基本类型的简单程序可能只访问栈，这是所有局部变量在可能的情况下存储的地方。但对于任何更复杂的程序，堆是大多数分配实际发生的地方：所有用 &lt;code>make&lt;/code> 或 &lt;code>new&lt;/code> 分配的内容、所有切片的内容，以及所有不能安全存储在栈上的内容。为了确定什么可以存储在栈上，什么需要放在堆上，Go 编译器使用一个称为 &lt;a href="https://tip.golang.org/doc/gc-guide#Where_Go_Values_Live">逃逸分析&lt;/a> 的过程。细节相当复杂，仅通过查看代码很难确定变量的存储位置。&lt;/p></description></item></channel></rss>
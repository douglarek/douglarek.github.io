<!doctype html><html lang=zh><head><title>JSpecify 空值用户指南 &ndash; Code talks</title><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/palettes/base16-dark.css><link rel=stylesheet href=/css/risotto.css><link rel=stylesheet href=/css/custom.css><link rel=icon href=/favicon.ico><meta property="og:title" content="JSpecify 空值用户指南 &ndash; Code talks"><meta property="og:url" content="/post/jspecify-nullness-user-guide/"><meta property="og:locale" content="zh-CN"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4TVXFV2XZM%20"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4TVXFV2XZM ")}</script></head><body><div class=page><header class=page__header><nav class="page__nav main-nav"><ul><li class=nomarker><h1 class=page__logo><a href=/ class=page__logo-inner>Code talks</a></h1></li><li class=main-nav__item><a class=nav-main-item href=/post title>Posts</a></li><li class=main-nav__item><a class=nav-main-item href=/tags title>Tags</a></li><li class=main-nav__item><a class=nav-main-item href=https://github.com/douglarek title>GitHub</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>JSpecify 空值用户指南</h1><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6649330439620894" crossorigin=anonymous></script></header><div class=content__body><p>本文翻译自 <a href=https://jspecify.dev/docs/user-guide/>Nullness User Guide</a>，版权归原作者所有。</p><p>在 Java 代码中，表达式是否可能求值为 <code>null</code> 通常只在自然语言中记录，甚至根本没有记录。JSpecify 的空值注解让程序员能够以一致且定义良好的方式表达 Java 代码的空值性。</p><p>JSpecify 定义了描述 Java 类型是否包含 <code>null</code> 值的注解。这些注解对以下方面很有用（例如）:</p><ul><li>阅读代码的程序员,</li><li>帮助开发人员避免 <code>NullPointerException</code> 的工具,</li><li>执行运行时检查和测试生成的工具,以及</li><li>文档系统。</li></ul><h2 id=java-变量是引用>Java 变量是引用</h2><p>在 Java 中，所有非基本类型变量要么是 <code>null</code>，要么是对对象的引用。我们经常认为像 <code>String x</code> 这样的声明意味着 <code>x</code> 是一个 <code>String</code>，但它实际上意味着 <code>x</code> <em>要么</em>是 <code>null</code> <em>要么</em>是对实际 <code>String</code> 对象的引用。JSpecify 为您提供了一种明确表达您真正含义的方法，即您是真的这样认为，还是您真的认为 <code>x</code> 绝对是对 <code>String</code> 对象的引用而不是 <code>null</code>。</p><h2 id=类型和空值性>类型和空值性</h2><p>JSpecify 为您提供了规则，用于确定每种类型用法具有四种空值性中的哪一种:</p><ul><li>它可以包含 <code>null</code>（它是"可空的"）。</li><li>它不会包含 <code>null</code>（它是"非空的"）。</li><li>仅对类型变量：如果替换它的类型参数包含 <code>null</code>，则它包含 <code>null</code>（它具有"参数化空值性"）。</li><li>我们不知道它是否可以包含 <code>null</code>（它具有"未指定的空值性"）。这相当于没有 JSpecify 注解的世界状态。</li></ul><p>对于给定的变量 <code>x</code>，如果 <code>x</code> 可以是 <code>null</code>，那么 <code>x.getClass()</code> 是不安全的，因为它可能产生 <code>NullPointerException</code>。如果 <code>x</code> 不能是 <code>null</code>，<code>x.getClass()</code> 永远不会产生 <code>NullPointerException</code>。如果我们不知道 <code>x</code> 是否可以是 <code>null</code>，我们就不知道 <code>x.getClass()</code> 是否安全（至少就 JSpecify 而言）。</p><p>&ldquo;不能是 <code>null</code>&rdquo; 的概念实际上应该附带一个脚注，即"如果所讨论的代码都不涉及未指定的空值性"。例如，如果您有一些代码将具有未指定空值性的类型传递给仅接受 <code>@NonNull</code> 参数的方法，那么工具可能允许它将可能为 <code>null</code> 的值传递给期望"不能是 <code>null</code>" 参数的方法。</p><p>有四个 JSpecify 注解一起用于指示所有类型用法的空值性:</p><ul><li>两个类型使用注解，指示特定类型用法是否包含 <code>null</code>：<a href=#nullable-%E5%92%8C-nonnull><code>@Nullable</code> 和 <code>@NonNull</code></a></li><li>一个作用域注解，让您避免大多数时候都要输入 <code>@NonNull</code>：<a href=#nullmarked><code>@NullMarked</code></a></li><li>另一个作用域注解，撤消 <code>@NullMarked</code> 的效果，以便您可以增量采用注解：<a href=#nullunmarked><code>@NullUnmarked</code></a></li></ul><h2 id=nullable-和-nonnull>@Nullable 和 @NonNull</h2><p>当类型用 <a href=https://jspecify.dev/docs/api/org/jspecify/annotations/Nullable.html><code>@Nullable</code></a> 注解时，表示该类型的值可以是 <code>null</code>。<code>@Nullable String x</code> 表示 <code>x</code> 可能是 <code>null</code>。使用这些值的代码必须能够处理 <code>null</code> 情况，并且可以将 <code>null</code> 分配给此类变量或将 <code>null</code> 传递给这些参数。</p><p>当类型用 <a href=https://jspecify.dev/docs/api/org/jspecify/annotations/NonNull.html><code>@NonNull</code></a> 注解时，表示该类型的值不应该是 <code>null</code>。<code>@NonNull String x</code> 表示 <code>x</code> 永远不应该是 <code>null</code>。使用这些值的代码可以假定它们不是 <code>null</code>，将 <code>null</code> 分配给这些值或将 <code>null</code> 传递给这些参数是一个坏主意。（有关如何避免大多数时候都要拼写 <code>@NonNull</code>，请参见<a href=#nullmarked>下文</a>。）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#a6e22e>@Nullable</span> String <span style=color:#a6e22e>emptyToNull</span>(<span style=color:#a6e22e>@NonNull</span> String x) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> x.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>?</span> <span style=color:#66d9ef>null</span> : x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#a6e22e>@NonNull</span> String <span style=color:#a6e22e>nullToEmpty</span>(<span style=color:#a6e22e>@Nullable</span> String x) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> x <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;&#34;</span> : x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在此示例中，<code>emptyToNull</code> 的参数用 <code>@NonNull</code> 注解，因此它不能是 <code>null</code>；<code>emptyToNull(null)</code> 不是有效的方法调用。<code>emptyToNull</code> 方法的主体依赖于该假设并立即调用 <code>x.isEmpty()</code>，如果 <code>x</code> 实际上是 <code>null</code>，则会抛出 <code>NullPointerException</code>。相反，<code>emptyToNull</code> 可能返回 <code>null</code>，因此其返回类型用 <code>@Nullable</code> 注解。</p><p>另一方面，<code>nullToEmpty</code> 承诺处理 <code>null</code> 参数，因此其参数用 <code>@Nullable</code> 注解以指示 <code>nullToEmpty(null)</code> 是有效的方法调用。它的主体考虑了参数为 <code>null</code> 的情况，并且不会抛出 <code>NullPointerException</code>。它不能返回 <code>null</code>，因此其返回类型用 <code>@NonNull</code> 注解。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doSomething</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// OK: nullToEmpty 接受 null 但不会返回它</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> length1 <span style=color:#f92672>=</span> nullToEmpty(<span style=color:#66d9ef>null</span>).<span style=color:#a6e22e>length</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 不 OK: emptyToNull 不接受 null；而且，它可能返回 null！</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> length2 <span style=color:#f92672>=</span> emptyToNull(<span style=color:#66d9ef>null</span>).<span style=color:#a6e22e>length</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>工具可以使用 <code>@Nullable</code> 和 <code>@NonNull</code> 注解来警告用户有关不安全的调用。</p><p>就 JSpecify 而言，<code>@NonNull String</code> 和 <code>@Nullable String</code> 是<em>不同的类型</em>。<code>@NonNull String</code> 类型的变量可以引用任何 <code>String</code> 对象。<code>@Nullable String</code> 类型的变量也可以，但它也可以是 <code>null</code>。这意味着 <code>@NonNull String</code> 是 <code>@Nullable String</code> 的<em>子类型</em>，就像 <code>Integer</code> 是 <code>Number</code> 的子类型一样。看待这一点的一种方式是，子类型缩小了可能值的范围。<code>Number</code> 变量可以从 <code>Integer</code> 分配，但也可以从 <code>Long</code> 分配。同时，<code>Integer</code> 变量不能从 <code>Number</code> 分配（因为该 <code>Number</code> 可能是 <code>Long</code> 或其他子类型）。同样，<code>@Nullable String</code> 可以从 <code>@NonNull String</code> 分配，但 <code>@NonNull String</code> 不能从 <code>@Nullable String</code> 分配（因为那可能是 <code>null</code>）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Example</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>useNullable</span>(<span style=color:#a6e22e>@Nullable</span> String x) { ... }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>useNonNull</span>(<span style=color:#a6e22e>@NonNull</span> String x) { ... }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>example</span>(<span style=color:#a6e22e>@Nullable</span> String nullable, <span style=color:#a6e22e>@NonNull</span> String nonNull) {
</span></span><span style=display:flex><span>    useNullable(nonNull); <span style=color:#75715e>// JSpecify 允许这样做</span>
</span></span><span style=display:flex><span>    useNonNull(nullable); <span style=color:#75715e>// JSpecify 不允许这样做</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=未注解的类型呢>未注解的类型呢？</h2><p>像 <code>String</code> 这样没有用 <code>@Nullable</code> 或 <code>@NonNull</code> 注解的类型意味着它一直以来的含义：它的值可能打算包含 <code>null</code>，也可能不包含，这取决于您能找到的任何文档（但请参见<a href=#nullmarked>下文</a>寻求帮助！）。JSpecify 称之为"未指定的空值性"。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Unannotated</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>whoKnows</span>(String x) { ... }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>example</span>(<span style=color:#a6e22e>@Nullable</span> String nullable) {
</span></span><span style=display:flex><span>    whoKnows(nullable); <span style=color:#75715e>// ¯\_(ツ)_/¯</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=nullmarked>@NullMarked</h2><p>如果必须用 <code>@Nullable</code> 或 <code>@NonNull</code> 注解 Java 代码中的每一个类型用法以避免未指定的空值性（尤其是一旦添加<a href=#%E6%B3%9B%E5%9E%8B>泛型</a>！），那将很烦人。</p><p>因此 JSpecify 为您提供了 <a href=https://jspecify.dev/docs/api/org/jspecify/annotations/NullMarked.html><code>@NullMarked</code></a> 注解。当您将 <code>@NullMarked</code> 应用于模块、包、类或方法时，意味着该作用域中未注解的类型被视为好像它们用 <code>@NonNull</code> 注解一样。（下面我们将看到，对于<a href=#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F>局部变量</a>和<a href=#%E5%A3%B0%E6%98%8E%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B>类型变量</a>有一些例外。）在 <code>@NullMarked</code> 覆盖的代码中，<code>String x</code> 的含义与 <code>@NonNull String x</code> 相同。</p><p>如果应用于模块，则其作用域是模块中的所有代码。如果应用于包，则其作用域是包中的所有代码。（请注意，包<em>不是</em>分层的；将 <code>@NullMarked</code> 应用于包 <code>com.foo</code> 不会使包 <code>com.foo.bar</code> 成为 <code>@NullMarked</code>。）如果应用于类、接口或方法，则其作用域是该类、接口或方法中的所有代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@NullMarked</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Strings</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>@Nullable</span> String <span style=color:#a6e22e>emptyToNull</span>(String x) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>?</span> <span style=color:#66d9ef>null</span> : x;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>nullToEmpty</span>(<span style=color:#a6e22e>@Nullable</span> String x) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;&#34;</span> : x;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这是上面的示例，其中包含方法的类用 <code>@NullMarked</code> 注解。类型的空值性与以前相同：<code>emptyToNull</code> 不接受 <code>null</code> 参数，但它可能返回 <code>null</code>；<code>nullToEmpty</code> 接受 <code>null</code> 参数，但它不会返回 <code>null</code>。但我们能够用更少的注解做到这一点。通常，使用 <code>@NullMarked</code> 将为您提供正确的空值语义和更少的注解。在 <code>@NullMarked</code> 代码中，您会习惯于将像 <code>String</code> 这样的普通、未注解的类型视为对 <code>String</code> 对象的真实引用，而永远不是 <code>null</code>。</p><p>如上所述，对于<a href=#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F>局部变量</a>和<a href=#%E5%A3%B0%E6%98%8E%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B>类型变量</a>，此解释有一些例外。</p><h3 id=nullunmarked>@NullUnmarked</h3><p>如果您正在将 JSpecify 注解应用于您的代码，您可能无法一次性注解所有代码。如果您现在可以将 <code>@NullMarked</code> 应用于部分代码，稍后再做其余部分，那比等到有时间注解所有内容要好。但这意味着您可能必须对模块、包或类进行空标记，<em>但某些类或方法除外</em>。为此，请将 <a href=https://jspecify.dev/docs/api/org/jspecify/annotations/NullUnmarked.html><code>@NullUnmarked</code></a> 应用于已经位于 <code>@NullMarked</code> 上下文中的包、类或方法。<code>@NullUnmarked</code> 只是撤消了周围 <code>@NullMarked</code> 的效果，因此未注解的类型具有未指定的空值性，除非它们用 <code>@Nullable</code> 或 <code>@NonNull</code> 注解，就像根本没有封闭的 <code>@NullMarked</code> 一样。<code>@NullUnmarked</code> 作用域可能反过来包含嵌套的 <code>@NullMarked</code> 元素，以使该较窄作用域内的大多数未注解类型用法为非空。</p><h2 id=局部变量>局部变量</h2><p><code>@Nullable</code> 和 <code>@NonNull</code> 不应用于局部变量——至少不应用于它们的根类型。（它们应该应用于类型参数和数组组件。）原因是可以根据分配给变量的值来<em>推断</em>变量是否可以是 <code>null</code>。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@NullMarked</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>myMethod</span>(<span style=color:#a6e22e>@Nullable</span> String one, String two) {
</span></span><span style=display:flex><span>    String anotherOne <span style=color:#f92672>=</span> one;
</span></span><span style=display:flex><span>    String anotherTwo <span style=color:#f92672>=</span> two;
</span></span><span style=display:flex><span>    String oneOrTwo <span style=color:#f92672>=</span> random() <span style=color:#f92672>?</span> one : two;
</span></span><span style=display:flex><span>    String twoOrNull <span style=color:#f92672>=</span> Strings.<span style=color:#a6e22e>emptyToNull</span>(two);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>分析器可以告诉所有这些变量除了 <code>anotherTwo</code> 都可以是 <code>null</code>。<code>anotherTwo</code> 不能是 <code>null</code>，因为 <code>two</code> 不能是 <code>null</code>：它不是 <code>@Nullable</code> 并且在 <code>@NullMarked</code> 的作用域内。<code>anotherOne</code> 可以是 <code>null</code>，因为它是从 <code>@Nullable</code> 参数分配的。<code>oneOrTwo</code> 可以是 <code>null</code>，因为它可能从 <code>@Nullable</code> 参数分配。并且 <code>twoOrNull</code> 可以是 <code>null</code>，因为它的值来自返回 <code>@Nullable String</code> 的方法。</p><h2 id=泛型>泛型</h2><p>当您使用泛型类型时，有关 <code>@Nullable</code>、<code>@NonNull</code> 和 <code>@NullMarked</code> 的规则与我们所看到的一样。例如，在 <code>@NullMarked</code> 上下文中，<code>List&lt;@Nullable String></code> 表示对 <code>List</code> 的引用（不是 <code>null</code>），其中每个元素都是对 <code>String</code> 对象的引用或 <code>null</code>；但 <code>List&lt;String></code> 表示一个列表（不是 <code>null</code>），其中每个元素都是对 <code>String</code> 对象的引用，<em>不能</em>是 <code>null</code>。</p><h3 id=声明泛型类型>声明泛型类型</h3><p>当您<em>声明</em>泛型类型时，事情会变得更复杂一些。考虑这个：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@NullMarked</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NumberList</span><span style=color:#f92672>&lt;</span>E <span style=color:#66d9ef>extends</span> Number<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> List<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> { ... }
</span></span></code></pre></div><p><code>extends Number</code> 为类型变量 <code>E</code> 定义了一个<em>边界</em>。这意味着您可以编写 <code>NumberList&lt;Integer></code>，因为 <code>Integer</code> 可以分配给 <code>Number</code>，但您不能编写 <code>NumberList&lt;String></code>，因为 <code>String</code> 不能分配给 <code>Number</code>。这是标准的 Java 行为。</p><p>但现在让我们考虑一下该边界与 <code>@NullMarked</code> 的关系。我们可以编写 <code>NumberList&lt;@Nullable Integer></code> 吗？</p><p>在 <code>@NullMarked</code> 内，请记住，未注解的类型与用 <code>@NonNull</code> 注解的类型相同。由于 <code>E</code> 的边界与 <code>@NonNull Number</code> 相同，而不是 <code>@Nullable Number</code>，这意味着 <code>E</code> 的类型参数不能是包含 <code>null</code> 的类型。那么 <code>@Nullable Integer</code> 不能是类型参数，因为它<em>可以</em>包含 <code>null</code>。（换句话说：<code>@Nullable Integer</code> <em>不是 <code>Number</code> 的子类型</em>。）</p><p>在 <code>@NullMarked</code> 内部，如果您希望能够为类型参数替换可空类型参数，则必须在类型变量上显式提供 <code>@Nullable</code> 边界：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@NullMarked</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NumberList</span><span style=color:#f92672>&lt;</span>E <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>@Nullable</span> Number<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> List<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> { ... }
</span></span></code></pre></div><p>现在编写 <code>NumberList&lt;@Nullable Integer></code> <em>是</em>合法的，因为 <code>@Nullable Integer</code> 可分配给边界 <code>@Nullable Number</code>。编写 <code>NumberList&lt;Integer></code> <em>也</em>是合法的，因为普通的 <code>Integer</code> 可分配给 <code>@Nullable Number</code>。在 <code>@NullMarked</code> 内部，普通的 <code>Integer</code> 与 <code>@NonNull Integer</code> 含义相同：对实际 <code>Integer</code> 值的引用，永远不会是 <code>null</code>。这只是意味着由 <code>E</code> 表示的值可以在 <code>NumberList</code> 的其他一些参数化上是 <code>null</code>，但在 <code>NumberList&lt;Integer></code> 的实例中不是。</p><p>当然，这假定 <code>List</code> 本身以允许可空类型参数的方式编写：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@NullMarked</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>List</span><span style=color:#f92672>&lt;</span>E <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>@Nullable</span> Object<span style=color:#f92672>&gt;</span> { ... }
</span></span></code></pre></div><p>如果是 <code>interface List&lt;E></code> 而不是 <code>interface List&lt;E extends @Nullable Object></code>，那么 <code>NumberList&lt;E extends @Nullable Number> implements List&lt;E></code> 将不合法。这是因为 <code>interface List&lt;E></code> 是 <code>interface List&lt;E extends Object></code> 的简写。在 <code>@NullMarked</code> 内部，普通的 <code>Object</code> 表示"不能是 <code>null</code> 的 <code>Object</code> 引用"。来自 <code>NumberList</code> 的 <code>&lt;E extends @Nullable Number></code> 将与 <code>&lt;E extends Object></code> 不兼容。</p><p>所有这些的含义是，每次定义像 <code>E</code> 这样的类型变量时，您都需要决定它是否可以用 <code>@Nullable</code> 类型替换。如果可以，那么它必须具有 <code>@Nullable</code> 边界。通常这将是 <code>&lt;E extends @Nullable Object></code>。另一方面，如果它<em>不能</em>表示 <code>@Nullable</code> 类型，则通过在其边界中不具有 <code>@Nullable</code> 来表示（包括根本没有显式边界的情况）。这是另一个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@NullMarked</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ImmutableList</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> List<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> { ... }
</span></span></code></pre></div><p>在这里，因为它是 <code>ImmutableList&lt;E></code> 而不是 <code>ImmutableList&lt;E extends @Nullable Object></code>，所以编写 <code>ImmutableList&lt;@Nullable String></code> 是不合法的。您只能编写 <code>ImmutableList&lt;String></code>，这是一个非空 <code>String</code> 引用的列表。</p><h3 id=在泛型类型中使用类型变量>在泛型类型中使用类型变量</h3><p>让我们看看 <code>List</code> 接口中的方法可能是什么样子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@NullMarked</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>List</span><span style=color:#f92672>&lt;</span>E <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>@Nullable</span> Object<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>add</span>(E element);
</span></span><span style=display:flex><span>  E <span style=color:#a6e22e>get</span>(<span style=color:#66d9ef>int</span> index);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Nullable</span> E <span style=color:#a6e22e>getFirst</span>();
</span></span><span style=display:flex><span>  Optional<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>@NonNull</span> E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>maybeFirst</span>();
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>add</code> 的参数类型 <code>E</code> 表示与 <code>List</code> 元素的实际类型兼容的引用。就像您不能将 <code>Integer</code> 添加到 <code>List&lt;String></code> 一样，您也不能将 <code>@Nullable String</code> 添加到 <code>List&lt;String></code>，但您<em>可以</em>将它添加到 <code>List&lt;@Nullable String></code>。</p><p>同样，<code>get</code> 的返回类型 <code>E</code> 表示它返回具有列表元素的实际类型的引用。如果列表是 <code>List&lt;@Nullable String></code>，那么该引用是 <code>@Nullable String</code>。如果列表是 <code>List&lt;String></code>，那么引用是 <code>String</code>。</p><p>另一方面，（虚构的）<code>getFirst</code> 方法的返回类型 <code>@Nullable E</code> 始终是 <code>@Nullable</code>。无论是在 <code>List&lt;@Nullable String></code> 还是 <code>List&lt;String></code> 上调用，它都将是 <code>@Nullable String</code>。这个想法是该方法返回列表的第一个元素，如果列表为空，则返回 <code>null</code>。同样，<code>Map</code> 中的真实方法 <code>@Nullable V get(Object key)</code> 和 <code>Queue</code> 中的 <code>@Nullable E peek()</code> 即使在 <code>V</code> 和 <code>E</code> 不能是 <code>null</code> 时也可以返回 <code>null</code>。</p><p>这里的区别是一个重要的区别，值得重复。像 <code>E</code> 这样的类型变量的使用只有在表示即使 <code>E</code> 本身不能是 <code>null</code> 也可以是 <code>null</code> 的引用时，才应该是 <code>@Nullable E</code>。否则，普通的 <code>E</code> 表示只有当 <code>E</code> 是 <code>@Nullable</code> 类型（如本例中的 <code>@Nullable String</code>）时才能是 <code>null</code> 的引用。（正如我们所看到的，只有当 <code>E</code> 的定义具有像 <code>&lt;E extends @Nullable Object></code> 这样的 <code>@Nullable</code> 边界时，<code>E</code> 才能是 <code>@Nullable</code> 类型。）</p><p>同样，您可以使用 <code>@NonNull E</code> 来指示<em>即使 <code>E</code> 可空</em>也是非空的类型。虚构的 <code>maybeFirst()</code> 方法返回非空的 <code>Optional</code>。<code>Optional</code> 对象只能保存非空值，因此将其定义为 <code>class Optional&lt;T></code> 是合理的；也就是说，它的类型参数不能是可空的。因此，即使对于 <code>List&lt;@Nullable String></code>，<code>maybeFirst()</code> 也必须返回 <code>Optional&lt;@NonNull String></code>。声明它的方法是将 <code>maybeFirst()</code> 的返回类型声明为 <code>Optional&lt;@NonNull E></code>。</p><p>我们之前看到 <code>@NullMarked</code> 通常意味着"引用不能是 <code>null</code>，除非它们被标记为 <code>@Nullable</code>"，并且这也不适用于局部变量。在这里我们看到它也不适用于未注解的类型变量使用，因为边界为 <code>@Nullable</code> 的未注解类型变量用法可能会替换为 <code>@Nullable</code> 类型参数。</p><h3 id=在泛型方法中使用类型变量>在泛型方法中使用类型变量</h3><p>我们刚刚看到的泛型类型的相同考虑基本上也适用于泛型方法。这是一个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@NullMarked</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Methods</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>@Nullable</span> T
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>firstOrNull</span>(List<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> list) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> list.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>?</span> <span style=color:#66d9ef>null</span> : list.<span style=color:#a6e22e>get</span>(0);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> T
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>firstOrNonNullDefault</span>(List<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> list, T defaultValue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> list.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>?</span> defaultValue : list.<span style=color:#a6e22e>get</span>(0);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>T <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>@Nullable</span> Object<span style=color:#f92672>&gt;</span> T
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>firstOrDefault</span>(List<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> list, T defaultValue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> list.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>?</span> defaultValue : list.<span style=color:#a6e22e>get</span>(0);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>T <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>@Nullable</span> Object<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>@Nullable</span> T
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>firstOrNullableDefault</span>(List<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> list, <span style=color:#a6e22e>@Nullable</span> T defaultValue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> list.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>?</span> defaultValue : list.<span style=color:#a6e22e>get</span>(0);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>firstOrNull</code> 方法将接受 <code>List&lt;String></code> 但不接受 <code>List&lt;@Nullable String></code>。当给定类型为 <code>List&lt;String></code> 的参数时，<code>T</code> 是 <code>String</code>，因此返回类型 <code>@Nullable T</code> 是 <code>@Nullable String</code>。输入列表不能包含 <code>null</code> 元素，但返回值可以是 <code>null</code>。</p><p><code>firstOrNonNullDefault</code> 方法再次不允许 <code>T</code> 是 <code>@Nullable</code> 类型，因此不允许使用 <code>List&lt;@Nullable String></code>。现在返回值也不是 <code>@Nullable</code>，这意味着它永远不会是 <code>null</code>。</p><p><code>firstOrDefault</code> 方法将接受 <code>List&lt;String></code> 和 <code>List&lt;@Nullable String></code>。在第一种情况下，<code>T</code> 是 <code>String</code>，因此 <code>defaultValue</code> 参数和返回值的类型是 <code>String</code>，这意味着两者都不能是 <code>null</code>。在第二种情况下，<code>T</code> 是 <code>@Nullable String</code>，因此 <code>defaultValue</code> 和返回值的类型是 <code>@Nullable String</code>，这意味着两者都可以是 <code>null</code>。</p><p><code>firstOrNullableDefault</code> 方法再次接受 <code>List&lt;String></code> 和 <code>List&lt;@Nullable String></code>，但现在 <code>defaultValue</code> 参数被标记为 <code>@Nullable</code>，因此即使在 <code>List&lt;String></code> 情况下它也可以是 <code>null</code>。同样，返回值是 <code>@Nullable T</code>，因此即使 <code>T</code> 不能是 <code>null</code>，它也可以是 <code>null</code>。</p><p>这是另一个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@NullMarked</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> List<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>@Nullable</span> T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>nullOutMatches</span>(List<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> list, T toRemove) {
</span></span><span style=display:flex><span>  List<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>@Nullable</span> T<span style=color:#f92672>&gt;</span> copy <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>(list);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> copy.<span style=color:#a6e22e>size</span>(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (copy.<span style=color:#a6e22e>get</span>(i).<span style=color:#a6e22e>equals</span>(toRemove)) {
</span></span><span style=display:flex><span>      copy.<span style=color:#a6e22e>set</span>(i, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> copy;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这需要一个 <code>List&lt;T></code>，根据定义不包含 <code>null</code> 元素，并生成一个 <code>List&lt;@Nullable T></code>，其中每个匹配 <code>toRemove</code> 的元素都用 <code>null</code> 替换。输出是 <code>List&lt;@Nullable T></code>，因为它<em>可以</em>包含 <code>null</code> 元素，即使 <code>T</code> 本身不能是 <code>null</code>。</p><h2 id=一些更微妙的细节>一些更微妙的细节</h2><p>前面的部分涵盖了您需要了解的 99% 的内容，以便能够有效地使用 JSpecify 注解。在这里，我们将介绍一些您可能不需要知道的细节。</p><h3 id=类型使用注解语法>类型使用注解语法</h3><p>在一些地方，像 <code>@Nullable</code> 和 <code>@NonNull</code> 这样的类型使用注解的语法可能令人惊讶。</p><ul><li><p>对于像 <code>Map.Entry</code> 这样的嵌套静态类型，如果您想说该值可以是 <code>null</code>，那么语法是 <code>Map.@Nullable Entry</code>。您通常可以通过直接导入嵌套类型来避免处理这个问题，但在这种情况下 <code>import java.util.Map.Entry</code> 可能不可取，因为 <code>Entry</code> 是一个非常常见的类型名称。</p></li><li><p>对于数组类型，如果您想说数组的<em>元素</em>可以是 <code>null</code>，那么语法是 <code>@Nullable String[]</code>。如果您想说<em>数组本身</em>可以是 <code>null</code>，那么语法是 <code>String @Nullable []</code>。如果元素和数组本身都可以是 <code>null</code>，语法是 <code>@Nullable String @Nullable []</code>。</p></li></ul><p>记住这一点的好方法是，<code>@Nullable</code> 后面的东西可以是 <code>null</code>。在 <code>Map.@Nullable Entry</code> 中可以是 <code>null</code> 的是 <code>Entry</code>，而不是 <code>Map</code>。在 <code>@Nullable String[]</code> 中可以是 <code>null</code> 的是 <code>String</code>，而在 <code>String @Nullable []</code> 中可以是 <code>null</code> 的是 <code>[]</code>，即数组。</p><h3 id=通配符边界>通配符边界</h3><p>在 <code>@NullMarked</code> 内部，通配符边界的工作方式与类型变量边界几乎完全相同。我们看到 <code>&lt;E extends @Nullable Number></code> 意味着 E 可以是 <code>@Nullable</code> 类型，而 <code>&lt;E extends Number></code> 意味着不能。同样，<code>List&lt;? extends @Nullable Number></code> 表示元素可以是 <code>null</code> 的列表，而 <code>List&lt;? extends Number></code> 意味着不能。</p><p>但是，当没有显式边界时，会有所不同。我们看到像 <code>&lt;E></code> 这样的类型变量定义意味着 <code>&lt;E extends Object></code>，这意味着它不是 <code>@Nullable</code>。但是 <code>&lt;?></code> 实际上意味着 <code>&lt;? extends B></code>，其中 <code>B</code> 是相应类型变量的边界。因此，如果我们有</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>List</span><span style=color:#f92672>&lt;</span>E <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>@Nullable</span> Object<span style=color:#f92672>&gt;</span> { ... }
</span></span></code></pre></div><p>那么 <code>List&lt;?></code> 的含义与 <code>List&lt;? extends @Nullable Object></code> 相同。如果我们有</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ImmutableList</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> List<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> { ... }
</span></span></code></pre></div><p>那么我们看到这意味着与</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ImmutableList</span><span style=color:#f92672>&lt;</span>E <span style=color:#66d9ef>extends</span> Object<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> List<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>相同，因此 <code>ImmutableList&lt;?></code> 的含义与 <code>ImmutableList&lt;? extends Object></code> 相同。在这里，<code>@NullMarked</code> 意味着 <code>Object</code> 排除 <code>null</code>。<code>List&lt;?></code> 的 <code>get(int)</code> 方法可以返回 <code>null</code>，但 <code>ImmutableList&lt;?></code> 的相同方法不能。</p></div><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//douglarek.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer class=content__footer></footer></section><section class=page__aside><div class=aside__content><p>2025-12-31</p><hr>On this page:<nav id=TableOfContents><ul><li><a href=#java-变量是引用>Java 变量是引用</a></li><li><a href=#类型和空值性>类型和空值性</a></li><li><a href=#nullable-和-nonnull>@Nullable 和 @NonNull</a></li><li><a href=#未注解的类型呢>未注解的类型呢？</a></li><li><a href=#nullmarked>@NullMarked</a><ul><li><a href=#nullunmarked>@NullUnmarked</a></li></ul></li><li><a href=#局部变量>局部变量</a></li><li><a href=#泛型>泛型</a><ul><li><a href=#声明泛型类型>声明泛型类型</a></li><li><a href=#在泛型类型中使用类型变量>在泛型类型中使用类型变量</a></li><li><a href=#在泛型方法中使用类型变量>在泛型方法中使用类型变量</a></li></ul></li><li><a href=#一些更微妙的细节>一些更微妙的细节</a><ul><li><a href=#类型使用注解语法>类型使用注解语法</a></li><li><a href=#通配符边界>通配符边界</a></li></ul></li></ul></nav></div></section><footer class=page__footer><p></p><br><br><p class=copyright>Copyright © 2025 Leo Douglas</p></footer></div></body></html>
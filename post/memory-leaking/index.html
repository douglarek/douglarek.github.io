<!doctype html><html lang=zh><head><title>Go 中的内存泄漏 &ndash; Code talks</title><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/palettes/base16-dark.css><link rel=stylesheet href=/css/risotto.css><link rel=stylesheet href=/css/custom.css><link rel=icon href=/favicon.ico><meta property="og:title" content="Go 中的内存泄漏 &ndash; Code talks"><meta property="og:url" content="/post/memory-leaking/"><meta property="og:locale" content="zh-CN"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4TVXFV2XZM%20"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4TVXFV2XZM ")}</script></head><body><div class=page><header class=page__header><nav class="page__nav main-nav"><ul><li class=nomarker><h1 class=page__logo><a href=/ class=page__logo-inner>Code talks</a></h1></li><li class=main-nav__item><a class=nav-main-item href=/post title>Posts</a></li><li class=main-nav__item><a class=nav-main-item href=/tags title>Tags</a></li><li class=main-nav__item><a class=nav-main-item href=https://github.com/douglarek title>GitHub</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>Go 中的内存泄漏</h1><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6649330439620894" crossorigin=anonymous></script></header><div class=content__body><p>本文翻译自 <a href=https://go101.org/article/memory-leaking.html>Memory Leaking</a>，版权归原作者所有。</p><p>当使用带有垃圾回收器(GC)的语言编程时, 通常我们不需要关心内存泄漏问题, 因为语言运行时(runtime)会定期收集未使用的内存. 但是, 我们确实需要了解一些可能导致轻微的或者真正的内存泄漏的特殊场景. 本文剩下的部分将列出几个这样的情况.</p><h2 id=求子字符串substrings导致的轻微内存泄露>求子字符串(Substrings)导致的轻微内存泄露</h2><p>Go 规范没有指定在子字符串表达式中涉及的结果字符串和基本字符串是否应共享相同的底层内存块，该内存块托管两个字符串的底层字节序列. Go 标准编译器/运行时确实会让它们共享相同的底层内存块. 这是一个很好的设计, 这既是内存也是 CPU 消耗的明智之举. 但它可能会导致内存泄漏.</p><p>例如, 调用下面的函数 f 后, 将有 1M 字节的内存泄漏(轻微), 直到其他地方修改了包级(package-level)变量 s0.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s0</span> <span style=color:#66d9ef>string</span> <span style=color:#75715e>// package level variable</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>s1</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 假设 s1 是一个长度大于 50 的字符串.</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s0</span> = <span style=color:#a6e22e>s1</span>[:<span style=color:#ae81ff>50</span>]
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 现在, s0 和 s1 共享相同的底层内存块.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// s1 现在不存活了, 但是 s0 依然存活.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 尽管仅有 50 个字节在内存块中,</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// s0 仍旧存活的事实阻止了这 1M 字节的内存块被回收.</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>为了避免这种轻微的内存泄漏, 我们可以将子字符串转换为一个 []byte 值, 然后将 []byte 值转换回 string.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>s1</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s0</span> = string([]byte(<span style=color:#a6e22e>s1</span>[:<span style=color:#ae81ff>50</span>]))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述避免这种轻微内存泄漏方法的缺点是在转换过程中发生了 50 字节的复制, 其中一个是不必要的.</p><p>我们可以使用 Go 标准编译器进行的<a href=https://go101.org/article/string.html#conversion-optimizations>一种优化</a>来避免一次复制, 并且伴随着浪费一个字节的小的额外成本.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>s1</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s0</span> = (<span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>s1</span>[:<span style=color:#ae81ff>50</span>])[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述方法的缺点是编译器优化可能会在以后失效，并且优化可能不适用于其他编译器.</p><p>避免类型内存泄漏的第三种方法是使用直到 Go 1.10 才开始支持的 strings.Builder .</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>s1</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Builder</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Grow</span>(<span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#a6e22e>s1</span>[:<span style=color:#ae81ff>50</span>])
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s0</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>String</span>()
</span></span><span style=display:flex><span>	<span style=color:#75715e>// b.Reset() // 如果 b 在其他地方会用到, 那么它必须在这里重置掉.</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>第三种方式的缺点是有点冗长(通过比较前两种方式).</p><h2 id=求子切片subslices导致的轻微内存泄露>求子切片(Subslices)导致的轻微内存泄露</h2><p>与求子串类似, 求子切片也可能导致轻微的内存泄漏. 在下面的代码中, 调用 g 函数后, 承载 s1 元素的内存块占用的大部分内存将会丢失(如果没有更多值引用内存块).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s0</span> []<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>g</span>(<span style=color:#a6e22e>s1</span> []<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 假设 s1 的长度远远大于 30.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s0</span> = <span style=color:#a6e22e>s1</span>[len(<span style=color:#a6e22e>s1</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>30</span>:]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果我们想避免这种轻微的内存泄漏, 我们必须复制 s0 的 30 个元素, 以便 s0 的存活不会阻止 s1 元素的内存块被回收.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>g</span>(<span style=color:#a6e22e>s1</span> []<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s0</span> = append([]int(<span style=color:#66d9ef>nil</span>), <span style=color:#a6e22e>s1</span>[len(<span style=color:#a6e22e>s1</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>30</span>:]<span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=不存活切片元素未重置指针导致的轻微内存泄露>不存活切片元素未重置指针导致的轻微内存泄露</h2><p>在下面的代码中, 调用 g 函数之后, 分配给切片 s 的第一个元素的内存块会丢失. 如果最后一个元素以后从未用作任何切片的元素, 则为最后一个元素分配的内存块也会丢失.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>g</span>() []<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>{new(<span style=color:#66d9ef>int</span>), new(<span style=color:#66d9ef>int</span>), new(<span style=color:#66d9ef>int</span>), new(<span style=color:#66d9ef>int</span>)}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果返回的切片仍然存活, 那么它将阻止收集 s 的元素的底层内存块, 从而防止从 s 的第一个元素到最后一个元素分配的两个内存块被收集, 尽管两个元素已经不存活了.</p><p>如果我们想避免这种轻微内存泄漏, 我们必须重置不存活元素中的指针(这里, 在函数 h 被调用后, 第一个和最后一个元素被视为不存活元素).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>h</span>() []<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>{new(<span style=color:#66d9ef>int</span>), new(<span style=color:#66d9ef>int</span>), new(<span style=color:#66d9ef>int</span>), new(<span style=color:#66d9ef>int</span>)}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#66d9ef>nil</span>; <span style=color:#a6e22e>s</span>[len(<span style=color:#a6e22e>s</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们经常需要重置<a href=https://go101.org/article/container.html#slice-manipulations>切片元素删除操作</a>中不存活元素的指针.</p><h2 id=迷失的-goroutines-导致的内存泄露>迷失的 Goroutines 导致的内存泄露</h2><p>有时, 对于代码设计中的一些逻辑失誤, 一個或多個 goroutine 會永遠處於阻塞狀態, 這將導致這些 goroutine 中使用的許多代碼塊永遠無法進行垃圾收集. 這是真正的內存泄漏.</p><p>例如, 如果將以下函數作為 goroutine 的啟動函數並將一個 nil channel 參數傳遞給它, 則 goroutine 將永遠阻塞. Go 运行时认为 goroutine 仍然存活, 所以为 s 分配的内存块将永远不会被收集.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>k</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int64</span>, <span style=color:#ae81ff>1e6</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span> { <span style=color:#75715e>// 如果 c 为 nil, 这里将永远阻塞</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 使用 s, ...</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们应该避免这种逻辑失误.</p><h2 id=终结器finalizers>终结器(Finalizers)</h2><p>为循环引用组内的成员设置 finalizer <a href=https://golang.org/pkg/runtime/#SetFinalizer>可能会阻止为这个循环引用组分配的所有内存块被收集</a>. 这不是轻微而是真正的内存泄露.</p><p>在下列函数被调用并退出之后, 为 x 和 y 分配的内存块不保证在未来会被垃圾收集器回收.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>memoryLeaking</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>v</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>20</span>]<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>finalizer</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>		 <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;finalizer called&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// SetFinalizer 会使 x 逃逸到堆上.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>SetFinalizer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>finalizer</span>)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 以下语句将导致 x 和 y 变得无法收集.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>t</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>y</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>x</span> <span style=color:#75715e>// y 也逃逸到了 堆上.</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>所以, 请避免为循环引用组中的值设置终结器(finalizers).</p></div><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//douglarek.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer class=content__footer></footer></section><section class=page__aside><div class=aside__content><p>2018-04-02</p><hr>On this page:<nav id=TableOfContents><ul><li><a href=#求子字符串substrings导致的轻微内存泄露>求子字符串(Substrings)导致的轻微内存泄露</a></li><li><a href=#求子切片subslices导致的轻微内存泄露>求子切片(Subslices)导致的轻微内存泄露</a></li><li><a href=#不存活切片元素未重置指针导致的轻微内存泄露>不存活切片元素未重置指针导致的轻微内存泄露</a></li><li><a href=#迷失的-goroutines-导致的内存泄露>迷失的 Goroutines 导致的内存泄露</a></li><li><a href=#终结器finalizers>终结器(Finalizers)</a></li></ul></nav></div></section><footer class=page__footer><p></p><br><br><p class=copyright>Copyright © 2025 Leo Douglas</p></footer></div></body></html>
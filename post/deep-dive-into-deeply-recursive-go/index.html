<!doctype html><html lang=zh><head><title>深入探讨 Go 语言的深度递归问题 &ndash; Code talks</title><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/palettes/base16-dark.css><link rel=stylesheet href=/css/risotto.css><link rel=stylesheet href=/css/custom.css><link rel=icon href=/favicon.ico><meta property="og:title" content="深入探讨 Go 语言的深度递归问题 &ndash; Code talks"><meta property="og:url" content="/post/deep-dive-into-deeply-recursive-go/"><meta property="og:locale" content="zh-CN"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4TVXFV2XZM%20"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4TVXFV2XZM ")}</script></head><body><div class=page><header class=page__header><nav class="page__nav main-nav"><ul><li class=nomarker><h1 class=page__logo><a href=/ class=page__logo-inner>Code talks</a></h1></li><li class=main-nav__item><a class=nav-main-item href=/post title>Posts</a></li><li class=main-nav__item><a class=nav-main-item href=/tags title>Tags</a></li><li class=main-nav__item><a class=nav-main-item href=https://github.com/douglarek title>GitHub</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>深入探讨 Go 语言的深度递归问题</h1><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6649330439620894" crossorigin=anonymous></script></header><div class=content__body><p>本文翻译自 <a href=https://mattermost.com/blog/a-deep-dive-into-deeply-recursive-go/>A deep dive into deeply recursive Go</a>，版权归原作者所有。</p><p>在我们 <a href=https://mattermost.com/blog/year-of-security-fixes-in-go/>之前关于 Go 安全性的博客文章</a> 中，我们写到了 2024 年修复的安全问题。其中一个要点与 9 月份发布的 Go 1.22.7 和 1.23.1 安全版本有关，该版本包含了对三个拒绝服务漏洞的修复。栈耗尽是这三个问题的根本原因，在没有明确以防御性方式编写的代码中极其常见。特别是在 Go 中，由于运行时处理栈耗尽的方式，栈耗尽比大多数内存安全语言更加危险。当栈耗尽发生时，崩溃是不可避免的。</p><p>需要进一步调查深度递归在 Go 中为何如此糟糕的机制、通常如何最终编写出深度递归的 Go 代码，以及可以采取什么措施来缓解栈耗尽问题。</p><h2 id=定义深度递归>定义深度递归</h2><p>有些问题本质上是递归的。这并不是说这些问题不能用迭代方式解决，而是递归解决方案更直观，通常也更易读。一个简单的例子是斐波那契数列，其定义本身就是递归的：数列中的每个元素都是前两个元素的和。编写一个打印数列的迭代 Go 程序很容易，但递归实现更直观，因为它直接映射到定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Fibonacci 打印斐波那契数列 1, 1, 2, 3, 5, ...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Fibonacci</span>(<span style=color:#a6e22e>f</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>uint64</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>next</span> <span style=color:#66d9ef>uint64</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>f</span>) &gt; <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>next</span> = <span style=color:#a6e22e>f</span>[len(<span style=color:#a6e22e>f</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>+</span> <span style=color:#a6e22e>f</span>[len(<span style=color:#a6e22e>f</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d, &#34;</span>, <span style=color:#a6e22e>next</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Fibonacci</span>(append(<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>next</span>)<span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个函数是 <strong>无限</strong> 递归的一个例子：它会一直打印斐波那契数列中的数字直到永远——或者直到某个外部力量阻止它。这也是一个 <strong>尾递归</strong> 函数的例子，其中递归步骤是函数体中的最后一条语句。这样的函数很容易转换为迭代形式，甚至可以通过编译器在称为尾调用优化（TCO）的过程中自动转换。不幸的是，<a href=https://github.com/golang/go/issues/22624>Go 不支持 TCO</a>，这意味着递归不会被优化掉，导致栈在数列的每一步都会增长。</p><h3 id=栈和堆的说明>栈和堆的说明</h3><p>Go 程序可以访问两种类型的内存：栈和堆，就像一般的计算机程序一样。一个只使用局部变量和基本类型的简单程序可能只访问栈，这是所有局部变量在可能的情况下存储的地方。但对于任何更复杂的程序，堆是大多数分配实际发生的地方：所有用 <code>make</code> 或 <code>new</code> 分配的内容、所有切片的内容，以及所有不能安全存储在栈上的内容。为了确定什么可以存储在栈上，什么需要放在堆上，Go 编译器使用一个称为 <a href=https://tip.golang.org/doc/gc-guide#Where_Go_Values_Live>逃逸分析</a> 的过程。细节相当复杂，仅通过查看代码很难确定变量的存储位置。</p><p>所有这些都很重要，因为栈和堆内存的管理方式完全不同。堆是垃圾收集器的领域，而栈使用更简单的机制增长和收缩。</p><p>栈上的值以非常有序的方式存储，正如其名称所示：每个 goroutine 都有自己的栈，由帧组成。调用函数会将一个帧推入栈并为其所有参数和局部变量预留空间。从函数返回会从栈中弹出相应的帧以及所有相关的值。这意味着当值不再可从创建它们的作用域访问时，它们会自动被丢弃。</p><p>在斐波那契例子中，调用函数会写入一个包含参数 f 的栈帧，从栈中预留一些字节。局部变量 <code>next</code> 逃逸到堆。递归步骤写入另一个具有相同布局但新值的帧，占用更多空间，如此往复，<strong>无穷无尽</strong>。</p><p>栈当然不是无限的。它受到物理内存和操作系统的限制，但最重要的是，它受到分配栈的 Go 运行时的限制。一个新的 goroutine 总是有一个固定大小的初始栈，<a href="https://cs.opensource.google/go/go/+/master:src/runtime/stack.go;l=75-76;drc=fa2bb342d7b0024440d996c2d6d6778b7a5e0247">具体来说是 2 KiB</a>。每当新帧不再适合分配的栈时，<a href="https://cs.opensource.google/go/go/+/master:src/runtime/stack.go;l=1078-1080;drc=fa2bb342d7b0024440d996c2d6d6778b7a5e0247">会分配一个大小加倍的新栈</a> 并复制旧栈。这会一直发生，直到达到两个限制之一：<a href=https://pkg.go.dev/runtime/debug#SetMaxStack>可配置的最大栈大小</a>，或固定的与架构相关的 <a href="https://cs.opensource.google/go/go/+/master:src/runtime/proc.go;l=154-166;drc=dad4f39971d89b56224d1eb44121305b1c0ef711">最大栈上限</a>。达到这些限制之一称为 <strong>栈耗尽</strong>。</p><h3 id=有限深度递归>有限深度递归</h3><p>现在应该很明显，斐波那契示例不会运行无限长的时间——实际上，它很快就会崩溃。这显然是导致栈耗尽的一种深度递归形式。但递归不需要是无限的，只要足够深就足以造成危害。</p><p>通过对示例的轻微修改，可以为递归引入限制：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// FibonacciUpToN 打印斐波那契数列 1, 1, 2, 3, 5, ...</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在 n 个元素后停止</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>FibonacciUpToN</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>f</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>uint64</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>f</span>) <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>n</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;...&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>next</span> <span style=color:#66d9ef>uint64</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>f</span>) &gt; <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>next</span> = <span style=color:#a6e22e>f</span>[len(<span style=color:#a6e22e>f</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>+</span> <span style=color:#a6e22e>f</span>[len(<span style=color:#a6e22e>f</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d, &#34;</span>, <span style=color:#a6e22e>next</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>FibonacciUpToN</span>(<span style=color:#a6e22e>n</span>, append(<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>next</span>)<span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>只要参数 <code>n</code> 固定为足够低的值，这段代码就能正常工作。当然，<strong>足够低</strong> 很难确定：该值应该小于任何系统或运行时限制，但单位不同——运行时以字节为单位测量栈深度，而代码只限制递归调用的次数——并且系统和运行时限制因平台而异。</p><p>在实践中，应该逐案确定确切的限制。例如，我们斐波那契函数的调用者可能对序列中第 50 个元素之后的值没有任何合理需求，所以为了安全起见，我们可能将 <code>n</code> 固定为 75，这仍然远低于会引起问题的任何值。实际上，第 100 个元素已经会溢出 <code>int64</code>，所以到那时打印的值无论如何都会不正确。在这种情况下，我们很幸运，因为很容易证明低限制的合理性。</p><p>通常，为限制找到合理性要困难得多。一个选择是将决定权留给调用者。在我们的斐波那契示例中，我们可能修复整数溢出问题并决定让调用者选择他们需要多少个元素，无论是 10、100 还是 10,000,000。值 n 成为输入的一部分，但递归不再是无限的，因为已经设置了明确的限制。将决定权交给调用者并不能消除做出决定的需要，然而，调用者可能不太有能力理解限制的含义，甚至可能不知道被调用的函数首先是递归的。调用者还可能从第三方提供的文件中读取输入。那么这是第三方的责任吗？如果第三方是恶意的呢？</p><p>使用参数值 10,000,000 调用 <code>FibonacciUpToN</code> 会使 Go 程序崩溃。但是用 <code>n</code> 设置为 5,000,000 或 2,000,000 来调用它呢？仅通过阅读代码很难判断。很明显，如果 <code>n</code> 被认为是用户输入，<code>FibonacciUpToN</code> 在可能产生有害结果的意义上仍然是深度递归的。</p><p>斐波那契示例仍然是一个容易处理的例子，因为调用者可以通过试错确定 2,000,000 对于特定目标平台和用例是一个安全限制，然后相应地验证输入，如果超过限制则优雅地失败。在现实世界中，测量输入本身的大小可能是具有挑战性的。递归解析器可能需要处理几千兆字节长度的输入文件，但只能容忍输入文件结构中的递归到某种程度。因此，输入的相关"大小"在解析每个结构的实际时刻之前是未知的。接下来我们将深入研究这样的例子。</p><h2 id=现实世界的深度递归>现实世界的深度递归</h2><p>到目前为止讨论的例子有些人为：为什么有人会想知道第 2,000,000 个斐波那契数呢？然而，现实的例子并不缺乏。递归经常用于解析递归文件格式、协议线格式和一般数据序列化格式，我们从中精选了一些案例。</p><h3 id=go-1183-中跳过-xml>Go 1.18.3 中跳过 XML</h3><p>XML 是固有递归数据序列化格式的一个突出例子：XML 元素可以包含其他 XML 元素，而其他 XML 元素又可以包含更多的 XML 元素：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;Element&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;AnotherElement&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;YetAnother&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;Element/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/YetAnother&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/AnotherElement&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/Element&gt;</span>
</span></span></code></pre></div><p>Go XML 解码器 <a href=https://pkg.go.dev/encoding/xml#Decoder><code>encoding/xml.Decode</code></a> 提供了 <a href=https://pkg.go.dev/encoding/xml#Decoder.Skip><code>Skip</code></a> 方法，可用于在解析期间丢弃任意元素。在低级用法中，它可以被直接调用，但像 <a href=https://pkg.go.dev/encoding/xml#Unmarshal><code>xml.Unmarshal</code></a> 函数这样的高级构造也会在内部调用它。</p><p>在 Go 版本 1.18.4 和 1.17.12 之前，<a href=https://pkg.go.dev/vuln/GO-2022-0521>20 兆字节的输入可能会使任何调用 Skip 的程序崩溃</a>，包括只是通过 Unmarshal 隐式调用它的程序。这是因为 Skip 会对任何无法识别的 XML 结构调用，然后对跳过时遇到的每个 StartElement 令牌递归调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Decoder</span>) <span style=color:#a6e22e>Skip</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>tok</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>Token</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>tok</span>.(<span style=color:#66d9ef>type</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>StartElement</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>Skip</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>EndElement</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>递归只受输入长度和其中递归结构深度的限制，即嵌套 XML 元素的数量。该方法不是尾递归的，但仍然很容易转换为迭代形式，这 <a href=https://go.googlesource.com/go/+/08c46ed43d80bbb67cb904944ea3417989be4af3%5E%21/>修复了</a> 问题：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Decoder</span>) <span style=color:#a6e22e>Skip</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>depth</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>tok</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>Token</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>tok</span>.(<span style=color:#66d9ef>type</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>StartElement</span>:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>depth</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>EndElement</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>depth</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>depth</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>修正后的代码不是隐式使用栈来跟踪元素的嵌套深度，而是在局部变量中显式跟踪嵌套深度，从不递归——对于这种特定情况来说是一个优雅的解决方案。</p><h3 id=googlegolangorgprotobuf-中的递归限制>google.golang.org/protobuf 中的递归限制</h3><p>在包 <code>google.golang.org/protobuf</code> 中可以找到一个更复杂的例子，其中 <a href=https://github.com/protocolbuffers/protobuf-go/releases/tag/v1.28.0>在版本 1.28.0 中引入了递归限制</a>，以响应我们对大输入崩溃的报告。与 XML 一样，Protocol Buffer 线格式的反序列化是一个固有的递归过程，Go 反序列化器是以深度递归的方式编写的。在版本 1.27.1 之前，反序列化 Protocol Buffer 的 Go 程序可能会被大约八兆字节的字节 <code>0x0B</code> 流崩溃。其中一个罪魁祸首是这段代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ConsumeFieldValue</span>(<span style=color:#a6e22e>num</span> <span style=color:#a6e22e>Number</span>, <span style=color:#a6e22e>typ</span> <span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>b</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>typ</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ... */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>StartGroupType</span>:
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>n0</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>num2</span>, <span style=color:#a6e22e>typ2</span>, <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ConsumeTag</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* ... */</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>ConsumeFieldValue</span>(<span style=color:#a6e22e>num2</span>, <span style=color:#a6e22e>typ2</span>, <span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span> <span style=color:#75715e>// 转发错误代码</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>n</span>:]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ... */</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>值 <code>0x0B</code> 会被 <code>ConsumeTag</code> 从 <code>b</code> 中读取并处理，使 <code>typ2</code> 总是被设置为 <code>StartGroupType</code>。然后函数 <code>ConsumeFieldValue</code> 会递归，像之前一样从 b 中读取另一个字节，只要栈可用就继续。</p><p>至于 <a href=https://go-review.googlesource.com/c/protobuf/+/385854>修复</a>，解决方案是回退到其他语言中实现的行为。Java 和 C++ 实现已经将嵌套深度限制为 100，所以在 Go 中强制执行类似的限制也相对安全：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ConsumeFieldValue</span>(<span style=color:#a6e22e>num</span> <span style=color:#a6e22e>Number</span>, <span style=color:#a6e22e>typ</span> <span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>b</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span><span style=color:#f92672>+</span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>consumeFieldValueD</span>(<span style=color:#a6e22e>num</span>, <span style=color:#a6e22e>typ</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>DefaultRecursionLimit</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>+</span>}
</span></span><span style=display:flex><span><span style=color:#f92672>+</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>consumeFieldValueD</span>(<span style=color:#a6e22e>num</span> <span style=color:#a6e22e>Number</span>, <span style=color:#a6e22e>typ</span> <span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>b</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>depth</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>typ</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ... */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>StartGroupType</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>+</span>       <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>depth</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span><span style=color:#f92672>+</span>           <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errCodeRecursionDepth</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span>       }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>n0</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>num2</span>, <span style=color:#a6e22e>typ2</span>, <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ConsumeTag</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* ... */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>-</span>           <span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>ConsumeFieldValue</span>(<span style=color:#a6e22e>num2</span>, <span style=color:#a6e22e>typ2</span>, <span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>+</span>           <span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>consumeFieldValueD</span>(<span style=color:#a6e22e>num2</span>, <span style=color:#a6e22e>typ2</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>depth</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span> <span style=color:#75715e>// 转发错误代码</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>n</span>:]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ... */</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这种情况的真正挑战不是管理递归的深度，而是库在典型软件项目依赖层次结构中出现的深度。与标准库或高级库不同，Protocol Buffers 不是你经常需要直接接触的东西。在我们的例子中，该库被用作我们依赖的 <a href=https://github.com/sajari/docconv>另一个库</a> 的一部分，用于从 Apple Pages 文件中提取文本，但由于通过传递依赖传播修复到直接依赖，然后最终到我们的产品需要时间，<a href=https://github.com/mattermost/mattermost/blob/e9a777f4e2a9f714e15a783715d586c24ab30304/services/docextractor/documents.go#L23-L24>我们选择通过禁用受影响的功能来保护我们的客户</a>。限制输入的大小不是一个选择：文字处理文档通常超过攻击所需的八兆字节，并且在不解析的情况下无法判断文档是否包含恶意 Protocol Buffer 流。</p><p>这是深度递归的一个常见挑战：因为最容易崩溃的解析器通常是低级库，而从外部通过限制输入来缓解崩溃通常是不可行的，应用程序开发者即使识别了这些问题也不能很好地修复它们。</p><h3 id=goparser-中缺少递归深度检查>go/parser 中缺少递归深度检查</h3><p>即使已经考虑了递归深度，在递归模式丰富的代码中始终如一地检查限制也可能很棘手。一个例子来自 <a href=https://pkg.go.dev/vuln/GO-2024-3105>CVE-2024-34155</a>，<code>go/parser</code> 中的崩溃，以及 <a href=https://go-review.googlesource.com/c/go/+/611238>其修复</a>，为原本正确执行限制的代码添加了一个遗漏的检查：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>parser</span>) <span style=color:#a6e22e>parseLiteralValue</span>(<span style=color:#a6e22e>typ</span> <span style=color:#a6e22e>ast</span>.<span style=color:#a6e22e>Expr</span>) <span style=color:#a6e22e>ast</span>.<span style=color:#a6e22e>Expr</span> {
</span></span><span style=display:flex><span><span style=color:#f92672>+</span>   <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>decNestLev</span>(<span style=color:#a6e22e>incNestLev</span>(<span style=color:#a6e22e>p</span>))
</span></span></code></pre></div><p>这里 <code>incNestLev</code> 将内部计数器的值增加 1，一旦函数返回，<code>decNestLev</code> 相应地减少该值。如果该值超过预先确定的阈值，<code>incNestLev</code> 就会恐慌（panic）。为什么这么容易错过这样一个明显的检查？因为解析器的内部调用图看起来像这样：</p><p><img src=/images/parser-call-graph.png alt="go/parser 调用图"></p><h2 id=栈耗尽崩溃的解剖>栈耗尽崩溃的解剖</h2><p>虽然 Go 并不总是有最大栈限制——触发致命错误的明确阈值——但自 <a href=https://go.dev/doc/go1.2#stack_size>2013 年发布的版本 1.2 以来</a> 就存在这样的限制。从那时起，变化很少。2013 年确定为"令人难以置信的大"的相同限制仍然存在。更大的最大栈上限在 2020 年引入，但它只对错误消息有实际影响。</p><p><a href="https://cs.opensource.google/go/go/+/master:src/runtime/stack.go;l=967;drc=fa2bb342d7b0024440d996c2d6d6778b7a5e0247"><code>runtime/newstack</code></a> 函数在 stack.go 中定义，负责强制执行栈限制。每当需要分配新栈时，该函数首先 <a href="https://cs.opensource.google/go/go/+/master:src/runtime/stack.go;l=1101-1109;drc=fa2bb342d7b0024440d996c2d6d6778b7a5e0247">检查</a> 新大小是否在两个限制内。如果超过任一限制，检查就会 <strong>抛出</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>newsize</span> &gt; <span style=color:#a6e22e>maxstacksize</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>newsize</span> &gt; <span style=color:#a6e22e>maxstackceiling</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>maxstacksize</span> &lt; <span style=color:#a6e22e>maxstackceiling</span> {
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;runtime: goroutine stack exceeds &#34;</span>, <span style=color:#a6e22e>maxstacksize</span>, <span style=color:#e6db74>&#34;-byte limit\n&#34;</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;runtime: goroutine stack exceeds &#34;</span>, <span style=color:#a6e22e>maxstackceiling</span>, <span style=color:#e6db74>&#34;-byte limit\n&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;runtime: sp=&#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>sp</span>), <span style=color:#e6db74>&#34; stack=[&#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span>), <span style=color:#e6db74>&#34;, &#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span>), <span style=color:#e6db74>&#34;]\n&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;stack overflow&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 Go 中，throw 不是像许多其他语言中的关键字或语言构造。相反，它是运行时内部某些部分使用的错误处理模式。</p><h3 id=致命错误>致命错误</h3><p>在 <a href="https://cs.opensource.google/go/go/+/master:src/runtime/panic.go;drc=96a6e147b2b02b1f070d559cb2c8e1c25c9b78c3"><code>panic.go</code></a> 中，Go 运行时定义了几种类型的错误，其中最熟悉的可能是标准 <a href="https://cs.opensource.google/go/go/+/master:src/runtime/panic.go;l=733;drc=96a6e147b2b02b1f070d559cb2c8e1c25c9b78c3"><code>panic</code></a> 及其各种变体：除零、越界错误、空指针解引用等等。恐慌不是栈耗尽时发生的情况——相反，会抛出致命错误。致命错误也有变体，但这里的特定变体是由函数 <a href="https://cs.opensource.google/go/go/+/master:src/runtime/panic.go;l=1085;drc=96a6e147b2b02b1f070d559cb2c8e1c25c9b78c3"><code>throw</code></a> 触发的。</p><p>使用致命错误的主要原因之一是恐慌很复杂，可能本身会增长栈，当然当栈限制已经达到时这是不可能的。另一方面，<code>throw</code> 函数是一个 nosplit 函数，<a href=https://go.dev/src/runtime/HACKING#nosplit-functions>意味着它永远不会增长栈</a>。</p><p>恐慌和致命错误之间面向用户的区别从"致命"一词中显而易见：与恐慌不同，<a href="https://cs.opensource.google/go/go/+/master:src/runtime/panic.go;l=1280-1285;drc=96a6e147b2b02b1f070d559cb2c8e1c25c9b78c3">致命错误无法恢复</a>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dopanic_m</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// crash 使用了相当数量的 nosplit 栈，而我们在 throw 中已经栈不足，</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 所以在系统栈上崩溃（与 fatalpanic 不同）。</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>crash</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=影响>影响</h3><p><a href=https://go.dev/blog/defer-panic-and-recover>当 Go 程序恐慌时</a>，运行时会展开栈，在途中执行每个 <code>defer</code> 语句，只有在到达末尾之前没有遇到 <code>recover</code> 调用时才会使程序崩溃。当运行时抛出致命错误时，这些都不会发生。这不仅意味着恢复是不可能的，而且 <code>defer</code> 语句中的其他代码也不会执行。因为延迟代码不会运行，数据丢失的可能性很高：即使是防护良好的代码也可能无法保存其状态，因为它只是停止运行。</p><p>深度递归不仅是临时的拒绝服务问题，还可能导致文件无法写入磁盘，甚至系统最终处于损坏状态，这可能会启用除 DoS 之外的其他攻击。</p><h2 id=防范栈耗尽>防范栈耗尽</h2><p>从上面的现实世界例子中，可以很容易地识别出缓解深度递归的两种一般方法：通过将算法转换为迭代形式来完全消除递归，或者显式跟踪递归深度并将其限制为预定的最大值。这两种方法都有其优缺点以及不同的实现考虑。</p><p>第三个选择是使用减少崩溃影响的架构设计模式。</p><h3 id=优先选择迭代>优先选择迭代</h3><p>许多递归算法，特别是像我们原始斐波那契示例这样的尾递归算法，很容易转换为迭代形式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// IterativeFibonacci 打印斐波那契数列 1, 1, 2, 3, 5, ...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>IterativeFibonacci</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>uint64</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>next</span> <span style=color:#66d9ef>uint64</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>f</span>) &gt; <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>next</span> = <span style=color:#a6e22e>f</span>[len(<span style=color:#a6e22e>f</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>+</span> <span style=color:#a6e22e>f</span>[len(<span style=color:#a6e22e>f</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d, &#34;</span>, <span style=color:#a6e22e>next</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>f</span> = append(<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>next</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当这在不损失可读性的情况下成为可能时，通常是最佳选择，因为迭代方法不会出错——没有意外遗漏检查或错误实现的风险。</p><p>有时实现迭代形式需要一些技巧，比如使用切片显式构造"栈"并将其存储在堆上——许多解析器采用的方法，比如 <a href=https://pkg.go.dev/golang.org/x/net/html><code>golang.org/x/net/html</code></a>，它显式跟踪几个栈并通过 <a href="https://cs.opensource.google/go/x/net/+/master:html/parse.go;l=2331;drc=6e41caea7e521db69a7de02895624c195575ed63">迭代</a> 调用 <a href="https://cs.opensource.google/go/x/net/+/master:html/parse.go;l=2305;drc=6e41caea7e521db69a7de02895624c195575ed63">函数引用</a> 而不是递归来进行解析。</p><p>然而，这样的技巧可能会使代码难以阅读，也难以被静态分析工具推理。</p><h3 id=限制递归深度>限制递归深度</h3><p>实现递归深度限制有几种方法。也许最明显的方法是引入一个额外的函数参数来跟踪深度，当超过常量限制时优雅地失败：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>maxDepth</span> = <span style=color:#ae81ff>10_000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>DoRecursiveThing</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>depth</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>depth</span> &gt; <span style=color:#a6e22e>maxDepth</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;max depth exceeded&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ... */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>DoRecursiveThing</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>depth</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>另一种选择是让调用者指定限制并向下计数。在这种情况下，调用者应该充分了解将限制设置得太高的影响：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>DoRecursiveThing</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>maxDepth</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>maxDepth</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;max depth exceeded&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ... */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>DoRecursiveThing</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>maxDepth</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当调用者不需要能够控制递归深度时，通常最好将深度参数从公共 API 中隐藏：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>maxDepth</span> = <span style=color:#ae81ff>10_000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>DoRecursiveThing</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>doRecursiveThingWithLimit</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>doRecursiveThingWithLimit</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>depth</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>depth</span> &gt; <span style=color:#a6e22e>maxDepth</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;max depth exceeded&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ... */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>doRecursiveThingWithLimit</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>depth</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在处理递归方法和结构体接收器时，也可以在结构体上跟踪深度：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>maxDepth</span> = <span style=color:#ae81ff>10_000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Thing</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>depth</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Thing</span>) <span style=color:#a6e22e>DoRecursiveThing</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>depth</span> &gt; <span style=color:#a6e22e>maxDepth</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;max depth exceeded&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ... */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>depth</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>DoRecursiveThing</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用这种方法，重要的是要注意，如果递归包含除尾调用之外的任何内容，深度需要在两个方向上跟踪：进入函数时增加，从函数出来时减少。如果有多个递归路径，在每个函数中包含检查可能会变成大量的复制粘贴，这是容易出错的。<code>go/parser</code> 采用的基于 <code>defer</code> 的方法是一个解决方案：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>maxDepth</span> = <span style=color:#ae81ff>10_000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Thing</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>depth</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>increaseDepth</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Thing</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Thing</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>depth</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>depth</span> &gt; <span style=color:#a6e22e>maxDepth</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#e6db74>&#34;max depth exceeded&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>无论选择哪种风格，所有这些方法的最大风险是忘记在需要的某些路径中添加递归检查。</p><h3 id=为崩溃容忍和恢复而架构>为崩溃容忍和恢复而架构</h3><p>通过选择适当的软件架构，也可以减少栈耗尽引起的崩溃的影响。在 Mattermost，我们实现了 <a href=https://docs.mattermost.com/scale/high-availability-cluster-based-deployment.html>高可用性集群</a>，其中单个进程崩溃不会使整个系统崩溃——相反，总是有另一个进程可用来接管。使用 <a href=https://docs.mattermost.com/deploy/server/deploy-kubernetes.html>Kubernetes</a>，<a href=https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy>崩溃也会被及时自动恢复</a>，意味着攻击者不能逐个击倒整个集群。数据库写入等操作使用事务来防止损坏。</p><p>尽管如此，这种保护只能是纵深防御措施和影响减少——即使是最好的架构也不能完全防止崩溃。崩溃仍然可能对用户可见，例如那些请求在崩溃时被同一服务器处理的用户看到的个别 HTTP 错误。</p><h2 id=从源头修复问题>从源头修复问题</h2><p>Go 运行时在栈耗尽时使程序崩溃没有技术原因。可恢复的恐慌同样是可能的。这并不意味着实现后者会很简单。相反，在已经栈不足并且恐慌时管理可用栈显然是非常复杂的。然而，使栈耗尽可恢复对整个 Go 生态系统将有重大的安全性和可靠性益处。</p><p>那么问题变成了是否值得实现这样的改变。一方面，存在在恐慌期间管理有限栈可用性的复杂性。另一方面，当前行为已经导致了许多安全问题。我们的答案是坚定的 <strong>可能</strong>，这就是为什么我们想要为更广泛的讨论开启这个话题。考虑到这一点，我们已经在 <a href=https://github.com/golang/go/issues/74577>Go 问题跟踪器上写了一个提案</a>，希望在那里看到评论。</p><h2 id=附录go-标准库中的栈耗尽错误>附录：Go 标准库中的栈耗尽错误</h2><p>为了更好地理解问题的规模，下面是过去在 Go 标准库中修复的栈耗尽漏洞的非详尽抽样。在撰写本文时，这 12 个 CVE 占 Go 有史以来发布的所有 CVE 的 9%。</p><table><thead><tr><th>ID</th><th>Package</th><th>Description</th></tr></thead><tbody><tr><td><strong>Issue #10415</strong></td><td>encoding/gob</td><td>stack overflow</td></tr><tr><td><strong>Issue #15879</strong></td><td>path/filepath</td><td>Glob with UNC path causes stack overflow</td></tr><tr><td><strong>CVE-2022-1962</strong></td><td>go/parser</td><td>stack exhaustion in all Parse* functions</td></tr><tr><td><strong>CVE-2022-24675</strong></td><td>encoding/pem</td><td>fix stack overflow in Decode</td></tr><tr><td><strong>CVE-2022-24921</strong></td><td>regexp</td><td>stack exhaustion compiling deeply nested expressions</td></tr><tr><td><strong>CVE-2022-28131</strong></td><td>encoding/xml</td><td>stack exhaustion in Decoder.Skip</td></tr><tr><td><strong>CVE-2022-30630</strong></td><td>io/fs</td><td>stack exhaustion in Glob</td></tr><tr><td><strong>CVE-2022-30631</strong></td><td>compress/gzip</td><td>stack exhaustion in Reader.Read</td></tr><tr><td><strong>CVE-2022-30632</strong></td><td>path/filepath</td><td>stack exhaustion in Glob</td></tr><tr><td><strong>CVE-2022-30633</strong></td><td>encoding/xml</td><td>stack exhaustion in Unmarshal</td></tr><tr><td><strong>CVE-2022-30635</strong></td><td>encoding/gob</td><td>stack exhaustion in Decoder.Decode</td></tr><tr><td><strong>CVE-2024-34155</strong></td><td>go/parser</td><td>stack exhaustion in all Parse* functions</td></tr><tr><td><strong>CVE-2024-34156</strong></td><td>encoding/gob</td><td>stack exhaustion in Decoder.Decode</td></tr><tr><td><strong>CVE-2024-34158</strong></td><td>go/build/constraint</td><td>stack exhaustion in Parse</td></tr></tbody></table><p>在具有类似功能的第三方库中，据传闻，栈耗尽甚至更加常见。</p></div><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//douglarek.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer class=content__footer></footer></section><section class=page__aside><div class=aside__content><p>2025-07-18</p><hr>On this page:<nav id=TableOfContents><ul><li><a href=#定义深度递归>定义深度递归</a><ul><li><a href=#栈和堆的说明>栈和堆的说明</a></li><li><a href=#有限深度递归>有限深度递归</a></li></ul></li><li><a href=#现实世界的深度递归>现实世界的深度递归</a><ul><li><a href=#go-1183-中跳过-xml>Go 1.18.3 中跳过 XML</a></li><li><a href=#googlegolangorgprotobuf-中的递归限制>google.golang.org/protobuf 中的递归限制</a></li><li><a href=#goparser-中缺少递归深度检查>go/parser 中缺少递归深度检查</a></li></ul></li><li><a href=#栈耗尽崩溃的解剖>栈耗尽崩溃的解剖</a><ul><li><a href=#致命错误>致命错误</a></li><li><a href=#影响>影响</a></li></ul></li><li><a href=#防范栈耗尽>防范栈耗尽</a><ul><li><a href=#优先选择迭代>优先选择迭代</a></li><li><a href=#限制递归深度>限制递归深度</a></li><li><a href=#为崩溃容忍和恢复而架构>为崩溃容忍和恢复而架构</a></li></ul></li><li><a href=#从源头修复问题>从源头修复问题</a></li><li><a href=#附录go-标准库中的栈耗尽错误>附录：Go 标准库中的栈耗尽错误</a></li></ul></nav></div></section><footer class=page__footer><p></p><br><br><p class=copyright>Copyright © 2025 Leo Douglas</p></footer></div></body></html>
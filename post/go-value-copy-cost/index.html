<!doctype html><html lang=zh><head><title>Go 的值拷贝代价 &ndash; Code talks</title><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/palettes/base16-dark.css><link rel=stylesheet href=/css/risotto.css><link rel=stylesheet href=/css/custom.css><link rel=icon href=/favicon.ico><meta property="og:title" content="Go 的值拷贝代价 &ndash; Code talks"><meta property="og:url" content="/post/go-value-copy-cost/"><meta property="og:locale" content="zh-CN"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4TVXFV2XZM%20"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4TVXFV2XZM ")}</script></head><body><div class=page><header class=page__header><nav class="page__nav main-nav"><ul><li class=nomarker><h1 class=page__logo><a href=/ class=page__logo-inner>Code talks</a></h1></li><li class=main-nav__item><a class=nav-main-item href=/post title>Posts</a></li><li class=main-nav__item><a class=nav-main-item href=/tags title>Tags</a></li><li class=main-nav__item><a class=nav-main-item href=https://github.com/douglarek title>GitHub</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>Go 的值拷贝代价</h1><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6649330439620894" crossorigin=anonymous></script></header><div class=content__body><p>本文翻译自 <a href=https://go101.org/article/value-copy-cost.html>Go Value Copy Costs</a>，版权归原作者所有。</p><p>值拷贝在 Go 语言编程中普遍发生. 赋值, 参数传递, channel 值发送以及接收操作都会涉及值拷贝. 本文将讨论 Go 中的值拷贝代价.</p><h2 id=值大小>值大小</h2><p>值的大小意味着该值(<a href=https://go101.org/article/value-part.html>直接部分</a>)将在内存中占用多少字节. 值的间接底层部分不影响值的大小.</p><p>在 Go 中, 如果两个值的类型属于同一类型, 并且类型不是基本类型, 字符串类型, 接口类型, 数组类型和结构体类型, 那么这两个值的大小总是相等.</p><p>事实上, 对于标准的 Go 编译器/运行时, 两个字符串值的大小也总是相等, 对于两个接口值的大小也是一样的.</p><p>对于标准的 Go 编译器/运行时, 相同类型的值具有相同的值大小. 因此, 我们通常将值的大小称为值类型的大小.</p><p>数组类型的大小取决于元素类型的大小和数组类型的长度. 数组类型大小是数组元素类型大小与数组长度的乘积.</p><p>结构类型的大小取决于它的所有字段. 因为在两个相邻字段之间可能存在一些填充字节, 所以结构类型大小不小于(并且通常大于)结构字段的相应类型大小之和.</p><p>下表列出了各种类型的值大小. 在表中, 一个字表示一个本地字, 它在 32 位操作系统上是 4 字节, 在 64 位操作系统上是 8 字节.</p><table><thead><tr><th style=text-align:left>类型</th><th style=text-align:left>Go 1.10 的值大小</th><th style=text-align:left>Go 规范要求</th></tr></thead><tbody><tr><td style=text-align:left>bool</td><td style=text-align:left>1 字节</td><td style=text-align:left>未明确</td></tr><tr><td style=text-align:left>int8, uint8(byte)</td><td style=text-align:left>1 字节</td><td style=text-align:left>1 字节</td></tr><tr><td style=text-align:left>int16, uint16</td><td style=text-align:left>2 字节</td><td style=text-align:left>2 字节</td></tr><tr><td style=text-align:left>int32 (rune), uint32, float32</td><td style=text-align:left>4 字节</td><td style=text-align:left>4 字节</td></tr><tr><td style=text-align:left>int64, uint64, float64, complex64</td><td style=text-align:left>8 字节</td><td style=text-align:left>8 字节</td></tr><tr><td style=text-align:left>complex128</td><td style=text-align:left>16 字节</td><td style=text-align:left>16 字节</td></tr><tr><td style=text-align:left>int, uint</td><td style=text-align:left>1 字</td><td style=text-align:left>体系结构相关, 4 或 8 个字节</td></tr><tr><td style=text-align:left>uintptr</td><td style=text-align:left>1 字</td><td style=text-align:left>足够大以存储指针值的未解释位</td></tr><tr><td style=text-align:left>string</td><td style=text-align:left>2 字</td><td style=text-align:left>未明确</td></tr><tr><td style=text-align:left>pointer</td><td style=text-align:left>1 字</td><td style=text-align:left>未明确</td></tr><tr><td style=text-align:left>slice</td><td style=text-align:left>3 字</td><td style=text-align:left>未明确</td></tr><tr><td style=text-align:left>map</td><td style=text-align:left>1 字</td><td style=text-align:left>未明确</td></tr><tr><td style=text-align:left>channel</td><td style=text-align:left>1 字</td><td style=text-align:left>未明确</td></tr><tr><td style=text-align:left>function</td><td style=text-align:left>1 字</td><td style=text-align:left>未明确</td></tr><tr><td style=text-align:left>interface</td><td style=text-align:left>2 字</td><td style=text-align:left>未明确</td></tr><tr><td style=text-align:left>struct</td><td style=text-align:left>所有字段的大小总和 + 填充字节数</td><td style=text-align:left>如果结构体类型不包含大于零的字段, 则其大小为零</td></tr><tr><td style=text-align:left>array</td><td style=text-align:left>(元素值大小) * (数组长度)</td><td style=text-align:left>如果数组的元素类型大小为零, 则其大小为零</td></tr></tbody></table><h2 id=值拷贝代价>值拷贝代价</h2><p>一般来说, 拷贝值的成本与值的大小成正比. 但是, 值的大小并不是计算值拷贝的唯一因素. 不同的 CPU 体系结构可能会针对具有特定大小的值专门优化值拷贝. 在实践中, 我们可以将大小小于四个本地字的值视为小值. 拷贝小值的成本很小.</p><p>除了大型结构和数组类型的值(对于标准的 Go 编译器), Go 中的大部分值都是小值.</p><p>为避免参数传递和 channel 值发送和接收操作中的大值复制成本, 我们应该尽量避免使用大型结构和数组类型作为函数和方法参数类型(包括方法接收器类型) 并避免使用大型结构和数组类型作为 channel 元素类型. 我们可以使用基类型为大型结构和数组类型的指针类型来应对这种情况.</p><p>另一方面, 我们还应该考虑在运行时使用太多指针造成的垃圾回收的负面影响. 因此, 是否应该使用大型结构体和数组类型或其相应的指针类型取决于特定的场景.</p><p>通常, 我们不应该使用基类型为 slice, map, channel map, function, 字符串和接口类型的指针类型. 这些假定的基本类型的值拷贝的成本很小.</p><p>如果元素类型是大值类型, 我们还应该尝试避免使用两次迭代变量形式来迭代数组和切片元素, 因为每个元素值都将被复制到迭代过程中的第二个迭代变量(译注: for range 中的 v).</p><p>以下是一个示例, 用于对 slice 元素迭代的不同方式进行基准测试.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>S</span> <span style=color:#66d9ef>struct</span>{<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>d</span>, <span style=color:#a6e22e>e</span> <span style=color:#66d9ef>int64</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sX</span>, <span style=color:#a6e22e>sY</span>, <span style=color:#a6e22e>sZ</span> = make([]<span style=color:#a6e22e>S</span>, <span style=color:#ae81ff>1000</span>), make([]<span style=color:#a6e22e>S</span>, <span style=color:#ae81ff>1000</span>), make([]<span style=color:#a6e22e>S</span>, <span style=color:#ae81ff>1000</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sumX</span>, <span style=color:#a6e22e>sumY</span>, <span style=color:#a6e22e>sumZ</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Benchmark_Loop</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sumX</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>j</span> &lt; len(<span style=color:#a6e22e>sX</span>); <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sumX</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>sX</span>[<span style=color:#a6e22e>j</span>].<span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Benchmark_Range_OneIterVar</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sumZ</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>sY</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sumZ</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>sY</span>[<span style=color:#a6e22e>j</span>].<span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Benchmark_Range_TwoIterVar</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sumY</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>sY</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sumY</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在测试文件的目录中运行基准测试, 我们将得到类似于以下的结果:</p><pre tabindex=0><code>Benchmark_Loop-4                500000   3228 ns/op
Benchmark_Range_OneIterVar-4    500000   3203 ns/op
Benchmark_Range_TwoIterVars-4   200000   6616 ns/op
</code></pre><p>我们可以发现, 双迭代变量形式的效率远低于其他两种形式.</p></div><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//douglarek.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer class=content__footer></footer></section><section class=page__aside><div class=aside__content><p>2018-04-27</p><hr>On this page:<nav id=TableOfContents><ul><li><a href=#值大小>值大小</a></li><li><a href=#值拷贝代价>值拷贝代价</a></li></ul></nav></div></section><footer class=page__footer><p></p><br><br><p class=copyright>Copyright © 2025 Leo Douglas</p></footer></div></body></html>
<!doctype html><html lang=zh><head><title>Java 虚拟线程 &ndash; Code talks</title><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/palettes/base16-dark.css><link rel=stylesheet href=/css/risotto.css><link rel=stylesheet href=/css/custom.css><link rel=icon href=/favicon.ico><meta property="og:title" content="Java 虚拟线程 &ndash; Code talks"><meta property="og:url" content="/post/java-virtual-threads/"><meta property="og:locale" content="zh-CN"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4TVXFV2XZM%20"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4TVXFV2XZM ")}</script></head><body><div class=page><header class=page__header><nav class="page__nav main-nav"><ul><li class=nomarker><h1 class=page__logo><a href=/ class=page__logo-inner>Code talks</a></h1></li><li class=main-nav__item><a class=nav-main-item href=/post title>Posts</a></li><li class=main-nav__item><a class=nav-main-item href=/tags title>Tags</a></li><li class=main-nav__item><a class=nav-main-item href=https://github.com/douglarek title>GitHub</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>Java 虚拟线程</h1><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6649330439620894" crossorigin=anonymous></script></header><div class=content__body><p>本文翻译自 <a href=https://dev.java/learn/new-features/virtual-threads/>Virtual Threads</a>，版权归原作者所有。</p><h2 id=为什么需要虚拟线程>为什么需要虚拟线程？</h2><p>Java 1.0 于 1995 年发布时，其 API 中包含约一百个类，其中就有 <code>java.lang.Thread</code>。Java 是第一个直接支持并发编程的主流编程语言。</p><p>从 Java 1.2 开始，每个 Java 线程都运行在底层操作系统提供的<strong>平台线程</strong>上。（在 Java 1.1 及之前的版本中，在某些平台上，所有 Java 线程由单个平台线程执行。）</p><p>平台线程的成本不低。启动一个平台线程需要数千条 CPU 指令，并且会消耗几兆字节的内存。服务器应用程序可能需要处理大量并发请求，为每个请求分配一个独立的平台线程变得不可行。在典型的服务器应用中，这些请求大部分时间都处于<strong>阻塞</strong>状态，等待数据库或其他服务返回结果。</p><p>提高吞吐量的传统方法是使用非阻塞 API。程序员不是等待结果，而是指定当结果可用时应调用哪个方法，以及在失败时调用另一个方法。这种方式很快就会变得令人不快，因为回调会不断嵌套。</p><p>JEP 425 在 Java 19 中引入了<strong>虚拟线程</strong>。多个虚拟线程运行在一个平台线程上。每当虚拟线程阻塞时，它就会被<strong>卸载</strong>，平台线程随即运行另一个虚拟线程。（&ldquo;虚拟线程"这个名称类似于虚拟内存映射到实际 RAM。）虚拟线程在 Java 20 中成为预览特性（JEP 436），并在 Java 21 中正式发布。</p><p>有了虚拟线程，阻塞的成本变得很低。当结果不能立即获得时，你只需在虚拟线程中阻塞即可。你可以使用熟悉的编程结构——分支、循环、try 块——而不是一系列回调。</p><p>虚拟线程在并发任务数量庞大且任务主要阻塞在网络 I/O 上时非常有用。对于 CPU 密集型任务，它们没有任何优势。对于此类任务，可以考虑使用<a href=https://dev.java/learn/api/streams/parallel-streams/>并行流</a>或<a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/RecursiveTask.html>递归 fork-join 任务</a>。</p><h2 id=创建虚拟线程>创建虚拟线程</h2><p>工厂方法 <code>Executors.newVirtualThreadPerTaskExecutor()</code> 返回一个 <code>ExecutorService</code>，它会在单独的虚拟线程中运行每个任务。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.*;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VirtualThreadDemo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> NTASKS <span style=color:#f92672>=</span> 100;
</span></span><span style=display:flex><span>        ExecutorService service <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newVirtualThreadPerTaskExecutor</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> NTASKS; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            service.<span style=color:#a6e22e>submit</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>long</span> id <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>threadId</span>();
</span></span><span style=display:flex><span>                LockSupport.<span style=color:#a6e22e>parkNanos</span>(1_000_000_000);
</span></span><span style=display:flex><span>                IO.<span style=color:#a6e22e>println</span>(id);
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>顺便说一下，这段代码使用 <code>LockSupport.parkNanos</code> 而不是 <code>Thread.sleep</code>，这样我们就不必捕获麻烦的 <code>InterruptedException</code>。</p><p>你可能在使用需要线程工厂的底层 API。要获取虚拟线程的工厂，请使用新的 <code>Thread.Builder</code> 类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Thread.<span style=color:#a6e22e>Builder</span> builder <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>ofVirtual</span>().<span style=color:#a6e22e>name</span>(<span style=color:#e6db74>&#34;request-&#34;</span>, 1);
</span></span><span style=display:flex><span>ThreadFactory factory <span style=color:#f92672>=</span> builder.<span style=color:#a6e22e>factory</span>();
</span></span></code></pre></div><p>现在，调用 <code>factory.newThread(myRunnable)</code> 会创建一个新的（未启动的）虚拟线程。<code>name</code> 方法配置构建器以设置线程名称 <code>request-1</code>、<code>request-2</code> 等。</p><p>你也可以使用构建器创建单个虚拟线程：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Thread t <span style=color:#f92672>=</span> builder.<span style=color:#a6e22e>unstarted</span>(myRunnable);
</span></span></code></pre></div><p>或者，如果你想立即启动线程：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Thread t <span style=color:#f92672>=</span> builder.<span style=color:#a6e22e>started</span>(myRunnable);
</span></span></code></pre></div><p>最后，对于快速演示，有一个便捷方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Thread t <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>startVirtualThread</span>(myRunnable);
</span></span></code></pre></div><p>请注意，只有第一种方法（使用执行器服务）适用于返回结果的任务（callables）。</p><h2 id=thread-api-的变化>Thread API 的变化</h2><p>在经过一系列不同 API 的实验后，Java 虚拟线程的设计者决定简单地重用熟悉的 <code>Thread</code> API。虚拟线程是 <code>Thread</code> 的实例。取消操作与平台线程相同，通过调用 <code>interrupt</code>。与以往一样，线程代码必须检查"中断"标志或调用会检查它的方法。（大多数阻塞方法都会检查。）</p><p>有一些区别。特别是，所有虚拟线程：</p><ul><li>属于单个线程组</li><li>优先级为 <code>NORM_PRIORITY</code></li><li>都是守护线程</li></ul><p>没有 API 可以构造具有其他线程组的虚拟线程。尝试在虚拟线程上调用 <code>setPriority</code> 或 <code>setDaemon</code> 不会产生任何效果。</p><p>静态方法 <code>Thread::getAllStackTraces</code> 返回所有<strong>平台</strong>线程的堆栈跟踪映射。虚拟线程不包括在内。</p><p>新的 <code>Thread::isVirtual</code> 实例方法可以判断线程是否为虚拟线程。</p><p>请注意，无法找到虚拟线程在哪个平台线程上执行。</p><p>Java 19 对 <code>Thread</code> API 进行了一些与虚拟线程无关的更改：</p><ul><li>现在有实例方法 <code>join(Duration)</code> 和 <code>sleep(Duration)</code>。</li><li>非 final 的 <code>getId</code> 方法已被弃用，因为有人可能重写它以返回线程 ID 以外的内容。请改用 final 的 <code>threadId</code> 方法。</li></ul><p>从 Java 20 开始，<code>stop</code>、<code>suspend</code> 和 <code>resume</code> 方法会对平台线程和虚拟线程抛出 <code>UnsupportedOperationException</code>。这些方法自 Java 1.2 起就已弃用，并自 Java 18 起标记为待删除。</p><h2 id=捕获任务结果>捕获任务结果</h2><p>你经常需要组合多个并发任务的结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Future<span style=color:#f92672>&lt;</span>T1<span style=color:#f92672>&gt;</span> f1 <span style=color:#f92672>=</span> service.<span style=color:#a6e22e>submit</span>(callable1);
</span></span><span style=display:flex><span>Future<span style=color:#f92672>&lt;</span>T2<span style=color:#f92672>&gt;</span> f2 <span style=color:#f92672>=</span> service.<span style=color:#a6e22e>submit</span>(callable2);
</span></span><span style=display:flex><span>result <span style=color:#f92672>=</span> combine(f1.<span style=color:#a6e22e>get</span>(), f2.<span style=color:#a6e22e>get</span>());
</span></span></code></pre></div><p>在虚拟线程出现之前，你可能会对阻塞的 <code>get</code> 调用感到不安。但现在阻塞的成本很低。下面是一个更具体的示例程序：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.net.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.net.http.*;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VirtualThreadDemo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException, ExecutionException {
</span></span><span style=display:flex><span>        ExecutorService service <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newVirtualThreadPerTaskExecutor</span>();
</span></span><span style=display:flex><span>        Future<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> f1 <span style=color:#f92672>=</span> service.<span style=color:#a6e22e>submit</span>(() <span style=color:#f92672>-&gt;</span> get(<span style=color:#e6db74>&#34;https://horstmann.com/random/adjective&#34;</span>));
</span></span><span style=display:flex><span>        Future<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> f2 <span style=color:#f92672>=</span> service.<span style=color:#a6e22e>submit</span>(() <span style=color:#f92672>-&gt;</span> get(<span style=color:#e6db74>&#34;https://horstmann.com/random/noun&#34;</span>));
</span></span><span style=display:flex><span>        String result <span style=color:#f92672>=</span> f1.<span style=color:#a6e22e>get</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> f2.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>        IO.<span style=color:#a6e22e>println</span>(result);
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> HttpClient client <span style=color:#f92672>=</span> HttpClient.<span style=color:#a6e22e>newHttpClient</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>get</span>(String url) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> request <span style=color:#f92672>=</span> HttpRequest.<span style=color:#a6e22e>newBuilder</span>().<span style=color:#a6e22e>uri</span>(<span style=color:#66d9ef>new</span> URI(url)).<span style=color:#a6e22e>GET</span>().<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> client.<span style=color:#a6e22e>send</span>(request, HttpResponse.<span style=color:#a6e22e>BodyHandlers</span>.<span style=color:#a6e22e>ofString</span>()).<span style=color:#a6e22e>body</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception ex) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> rex <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RuntimeException();
</span></span><span style=display:flex><span>            rex.<span style=color:#a6e22e>initCause</span>(ex);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> rex;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果你有一个具有相同结果类型的任务列表，可以使用 <code>invokeAll</code> 方法，然后对每个 <code>Future</code> 调用 <code>get</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> callables <span style=color:#f92672>=</span> ...;
</span></span><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> results <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> f : service.<span style=color:#a6e22e>invokeAll</span>(callables))
</span></span><span style=display:flex><span>    results.<span style=color:#a6e22e>add</span>(f.<span style=color:#a6e22e>get</span>());
</span></span></code></pre></div><p>同样，这里有一个更具体的示例程序：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.net.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.net.http.*;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VirtualThreadDemo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException, ExecutionException {
</span></span><span style=display:flex><span>        ExecutorService service <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newVirtualThreadPerTaskExecutor</span>();
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>Callable<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> callables <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> ADJECTIVES <span style=color:#f92672>=</span> 4;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;=</span> ADJECTIVES; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            callables.<span style=color:#a6e22e>add</span>(() <span style=color:#f92672>-&gt;</span> get(<span style=color:#e6db74>&#34;https://horstmann.com/random/adjective&#34;</span>));
</span></span><span style=display:flex><span>        callables.<span style=color:#a6e22e>add</span>(() <span style=color:#f92672>-&gt;</span> get(<span style=color:#e6db74>&#34;https://horstmann.com/random/noun&#34;</span>));
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> results <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Future<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> f : service.<span style=color:#a6e22e>invokeAll</span>(callables))
</span></span><span style=display:flex><span>            results.<span style=color:#a6e22e>add</span>(f.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>        IO.<span style=color:#a6e22e>println</span>(String.<span style=color:#a6e22e>join</span>(<span style=color:#e6db74>&#34; &#34;</span>, results));
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> HttpClient client <span style=color:#f92672>=</span> HttpClient.<span style=color:#a6e22e>newHttpClient</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>get</span>(String url) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> request <span style=color:#f92672>=</span> HttpRequest.<span style=color:#a6e22e>newBuilder</span>().<span style=color:#a6e22e>uri</span>(<span style=color:#66d9ef>new</span> URI(url)).<span style=color:#a6e22e>GET</span>().<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> client.<span style=color:#a6e22e>send</span>(request, HttpResponse.<span style=color:#a6e22e>BodyHandlers</span>.<span style=color:#a6e22e>ofString</span>()).<span style=color:#a6e22e>body</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception ex) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> rex <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RuntimeException();
</span></span><span style=display:flex><span>            rex.<span style=color:#a6e22e>initCause</span>(ex);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> rex;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=限流>限流</h2><p>虚拟线程提高了应用程序的吞吐量，因为你可以拥有比平台线程更多的并发任务。这可能会对任务调用的服务造成压力。例如，Web 服务可能无法承受大量并发请求。</p><p>对于平台线程，一个简单（尽管粗糙）的调优因素是这些任务的线程池大小。但你不应该池化虚拟线程。在虚拟线程上调度任务，然后在平台线程上调度这些虚拟线程显然是低效的。那么好处是什么呢？将虚拟线程数量限制为服务可以容忍的少量并发请求？那你为什么还要使用虚拟线程呢？</p><p>对于虚拟线程，你应该使用替代机制来控制对有限资源的访问。不要对并发任务进行整体限制，而是以适当的方式保护每个资源。对于数据库连接，连接池可能已经做了正确的事情。访问 Web 服务时，你了解自己的服务，可以提供适当的限流。</p><p>举个例子，在我的个人网站上，我提供了生成随机项目的演示服务。如果短时间内来自同一 IP 地址的大量请求，托管公司会将该 IP 地址列入黑名单。</p><p>以下示例程序展示了使用简单信号量进行限流，允许少量并发请求。当超过最大值时，<code>acquire</code> 方法会阻塞，但这没关系。使用虚拟线程，阻塞的成本很低。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.net.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.net.http.*;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RateLimitDemo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException, ExecutionException {
</span></span><span style=display:flex><span>        ExecutorService service <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newVirtualThreadPerTaskExecutor</span>();
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>Future<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> futures <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> TASKS <span style=color:#f92672>=</span> 250;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;=</span> TASKS; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            futures.<span style=color:#a6e22e>add</span>(service.<span style=color:#a6e22e>submit</span>(() <span style=color:#f92672>-&gt;</span> get(<span style=color:#e6db74>&#34;https://horstmann.com/random/word&#34;</span>)));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Future<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> f : futures)
</span></span><span style=display:flex><span>            IO.<span style=color:#a6e22e>print</span>(f.<span style=color:#a6e22e>get</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>        IO.<span style=color:#a6e22e>println</span>();
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> HttpClient client <span style=color:#f92672>=</span> HttpClient.<span style=color:#a6e22e>newHttpClient</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Semaphore SEMAPHORE <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Semaphore(20);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>get</span>(String url) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> request <span style=color:#f92672>=</span> HttpRequest.<span style=color:#a6e22e>newBuilder</span>().<span style=color:#a6e22e>uri</span>(<span style=color:#66d9ef>new</span> URI(url)).<span style=color:#a6e22e>GET</span>().<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>            SEMAPHORE.<span style=color:#a6e22e>acquire</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>sleep</span>(100);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> client.<span style=color:#a6e22e>send</span>(request, HttpResponse.<span style=color:#a6e22e>BodyHandlers</span>.<span style=color:#a6e22e>ofString</span>()).<span style=color:#a6e22e>body</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                SEMAPHORE.<span style=color:#a6e22e>release</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception ex) {
</span></span><span style=display:flex><span>            ex.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> rex <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RuntimeException();
</span></span><span style=display:flex><span>            rex.<span style=color:#a6e22e>initCause</span>(ex);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> rex;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=固定>固定</h2><p>虚拟线程调度器将虚拟线程挂载到载体线程上。默认情况下，载体线程的数量与 CPU 核心数相同。你可以使用 <code>jdk.virtualThreadScheduler.parallelism</code> VM 选项调整该数量。</p><p>当虚拟线程执行阻塞操作时，它应该从其载体线程上卸载，然后载体线程可以执行另一个虚拟线程。然而，在某些情况下，这种卸载是不可能的。在某些情况下，虚拟线程调度器会通过启动另一个载体线程来补偿。例如，在 JDK 21 中，许多文件 I/O 操作和调用 <code>Object.wait</code> 时会发生这种情况。你可以使用 <code>jdk.virtualThreadScheduler.maxPoolSize</code> VM 选项控制载体线程的最大数量。</p><p>在以下两种情况下，线程被称为<strong>固定</strong>：</p><ul><li>执行 <code>synchronized</code> 方法或代码块时</li><li>调用本地方法或外部函数时</li></ul><p>固定本身并不坏。但是当固定的线程阻塞时，它无法被卸载。载体线程被阻塞，并且在 Java 21 中，不会启动额外的载体线程。这会减少运行虚拟线程的载体线程。</p><p>如果 <code>synchronized</code> 用于避免内存操作中的竞态条件，固定是无害的。但是，如果有阻塞调用，最好将 <code>synchronized</code> 替换为 <code>ReentrantLock</code>。当然，这只有在你能控制源代码时才可行。</p><p>要查找固定的线程是否被阻塞，请使用以下选项之一启动 JVM：</p><pre tabindex=0><code>-Djdk.tracePinnedThreads=short -Djdk.tracePinnedThreads=full
</code></pre><p>你会得到一个堆栈跟踪，显示固定的线程何时阻塞：</p><pre tabindex=0><code>... org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) &lt;== monitors:1
...
</code></pre><p>请注意，每个固定位置只会收到一次警告！</p><p>或者，使用 Java Flight Recorder 记录，使用你喜欢的任务控制查看器查看，并查找 <code>VirtualThreadPinned</code> 和 <code>VirtualThreadSubmitFailed</code> 事件。</p><p>JVM 最终将实现 <code>synchronized</code> 方法或代码块不再导致固定。那时你只需要担心本地代码的固定。</p><p>以下示例程序展示了固定的实际情况。我们启动多个在同步方法中休眠的虚拟线程，阻塞它们的载体线程。添加了许多不执行任何工作的虚拟线程。但它们无法被调度，因为载体线程池已经完全耗尽。请注意，当你执行以下操作时，问题会消失：</p><ul><li>使用 <code>ReentrantLock</code></li><li>不使用虚拟线程</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.locks.*;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PinningDemo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException, ExecutionException {
</span></span><span style=display:flex><span>        ExecutorService service <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newVirtualThreadPerTaskExecutor</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Executors.newCachedThreadPool();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> TASKS <span style=color:#f92672>=</span> 20;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>nanoTime</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;=</span> TASKS; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            service.<span style=color:#a6e22e>submit</span>(() <span style=color:#f92672>-&gt;</span> block());
</span></span><span style=display:flex><span>            <span style=color:#75715e>// service.submit(() -&gt; rblock());</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;=</span> TASKS; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            service.<span style=color:#a6e22e>submit</span>(() <span style=color:#f92672>-&gt;</span> noblock());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> end <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>nanoTime</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%.2f%n&#34;</span>, (end <span style=color:#f92672>-</span> start) <span style=color:#f92672>*</span> 1E<span style=color:#f92672>-</span>9);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>block</span>() {
</span></span><span style=display:flex><span>        IO.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Entering block &#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>());
</span></span><span style=display:flex><span>        LockSupport.<span style=color:#a6e22e>parkNanos</span>(1_000_000_000);
</span></span><span style=display:flex><span>        IO.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Exiting block &#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Lock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rblock</span>() {
</span></span><span style=display:flex><span>        lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            IO.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Entering rblock &#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>());
</span></span><span style=display:flex><span>            LockSupport.<span style=color:#a6e22e>parkNanos</span>(1_000_000_000);
</span></span><span style=display:flex><span>            IO.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Exiting rblock &#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>());
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>noblock</span>() {
</span></span><span style=display:flex><span>        IO.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Entering noblock &#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>());
</span></span><span style=display:flex><span>        LockSupport.<span style=color:#a6e22e>parkNanos</span>(1_000_000_000);
</span></span><span style=display:flex><span>        IO.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Exiting noblock &#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=线程本地变量>线程本地变量</h2><p><strong>线程本地变量</strong>是一个对象，其 <code>get</code> 和 <code>set</code> 方法访问的值取决于当前线程。为什么你会想要这样的东西而不是使用全局或局部变量呢？经典的应用场景是非线程安全的服务，例如 <code>SimpleDateFormat</code>，或者会遭受竞争的服务，例如随机数生成器。每个线程的实例可以比受锁保护的全局实例性能更好。</p><p>线程本地变量的另一个常见用途是提供"隐式"上下文，例如为每个任务正确配置的数据库连接。任务代码不需要将上下文从一个方法传递到另一个方法，而是在需要访问数据库时简单地读取线程本地变量。</p><p>迁移到虚拟线程时，线程本地变量可能会成为问题。虚拟线程可能远多于线程池中的线程，现在你有更多的线程本地实例。在这种情况下，你应该重新考虑共享策略。</p><p>要在你的应用中定位线程本地变量的使用，请使用 VM 标志 <code>jdk.traceVirtualThreadLocals</code> 运行。当虚拟线程更改线程本地变量时，你会得到一个堆栈跟踪。</p><h2 id=总结>总结</h2><ul><li>当你有许多主要阻塞在网络 I/O 上的任务时，使用虚拟线程来提高吞吐量</li><li>主要好处是熟悉的"同步"编程风格，无需回调</li><li>不要池化虚拟线程；使用其他机制进行限流</li><li>检查固定并在必要时进行缓解</li><li>在虚拟线程中最小化线程本地变量的使用</li></ul></div><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//douglarek.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer class=content__footer></footer></section><section class=page__aside><div class=aside__content><p>2025-12-11</p><hr>On this page:<nav id=TableOfContents><ul><li><a href=#为什么需要虚拟线程>为什么需要虚拟线程？</a></li><li><a href=#创建虚拟线程>创建虚拟线程</a></li><li><a href=#thread-api-的变化>Thread API 的变化</a></li><li><a href=#捕获任务结果>捕获任务结果</a></li><li><a href=#限流>限流</a></li><li><a href=#固定>固定</a></li><li><a href=#线程本地变量>线程本地变量</a></li><li><a href=#总结>总结</a></li></ul></nav></div></section><footer class=page__footer><p></p><br><br><p class=copyright>Copyright © 2025 Leo Douglas</p></footer></div></body></html>
<!doctype html><html lang=zh><head><title>Java 并行流 &ndash; Code talks</title><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/palettes/base16-dark.css><link rel=stylesheet href=/css/risotto.css><link rel=stylesheet href=/css/custom.css><link rel=icon href=/favicon.ico><meta property="og:title" content="Java 并行流 &ndash; Code talks"><meta property="og:url" content="/post/parallel-streams/"><meta property="og:locale" content="zh-CN"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4TVXFV2XZM%20"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4TVXFV2XZM ")}</script></head><body><div class=page><header class=page__header><nav class="page__nav main-nav"><ul><li class=nomarker><h1 class=page__logo><a href=/ class=page__logo-inner>Code talks</a></h1></li><li class=main-nav__item><a class=nav-main-item href=/post title>Posts</a></li><li class=main-nav__item><a class=nav-main-item href=/tags title>Tags</a></li><li class=main-nav__item><a class=nav-main-item href=https://github.com/douglarek title>GitHub</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>Java 并行流</h1><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6649330439620894" crossorigin=anonymous></script></header><div class=content__body><p>本文翻译自 <a href=https://dev.java/learn/api/streams/parallel-streams/>Parallelizing Streams</a>，版权归原作者所有。</p><h2 id=优化流计算>优化流计算</h2><p>Stream API 的一个非常令人兴奋的特性是流能够并行处理数据。使用 Stream API 并行处理数据非常简单，只需在任何现有流上调用 <code>parallel()</code> 方法即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> parallelSum <span style=color:#f92672>=</span> IntStream.<span style=color:#a6e22e>range</span>(0, 10)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>parallel</span>()
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>sum</span>();
</span></span><span style=display:flex><span>IO.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Sum = &#34;</span> <span style=color:#f92672>+</span> parallelSum);
</span></span></code></pre></div><p>运行此代码会得到以下结果。</p><pre tabindex=0><code>Sum = 45
</code></pre><p>这个求和实际上是并行计算的。不过在这么小的示例中，你可能不会注意到任何性能提升。</p><p>为什么要并行计算数据？可能是为了更快地得到计算结果。并行流会比顺序流更快地给出结果吗？这个问题的答案并不像听起来那么简单。在某些情况下是的，但在其他一些情况下，不幸的是，不会。尽管听起来令人失望，但并行流并不总是比顺序流快。</p><p>考虑到这一点，你应该谨慎：选择使用并行流不是一个可以轻易做出的决定。在考虑并行化之前，你需要问自己几个问题。</p><p>首先，问问自己，你需要它吗？你的应用程序中是否有未满足的性能要求？你确定性能问题来自你正在考虑并行计算的流处理吗？你计划如何衡量性能提升，以确保对这个特定计算并行化确实改善了应用程序的性能？</p><p>并行化会消耗更多的计算能力。你是否有空闲的 CPU 或 CPU 核心可以分配给这个计算？你能否在不减慢应用程序其余部分的情况下为计算分配更多 CPU 周期？</p><p>并行化会消耗线程。你是否有空闲线程可以分配给计算？如果你在 Web 服务器中运行的应用程序上工作，那么你的线程用于处理 HTTP 请求。你愿意将它们用于其他事情吗？</p><p>一旦你选择了并行化，那么你需要确保流计算的性能确实得到了改善。你应该在尽可能接近生产环境的上下文中测量这种性能提升。</p><p>在本教程中，我们涵盖了几个关键要素，这些要素将帮助你评估并行化可能带来的收益，以及一些应该让你对并行化保持警惕的其他要素。但归根结底，唯一能告诉你并行化是否值得的是测试和测量执行时间。</p><h2 id=并行化实现>并行化实现</h2><p>Stream API 中的并行化是通过递归分解流正在处理的数据来实现的。它构建在 JDK 7 中添加的 Fork/Join 框架之上。</p><p>分解包括将流正在处理的数据分成两部分。然后每个部分由自己的 CPU 核心处理，该核心可能决定再次递归分割它。</p><p>在某个时刻，框架将决定给定部分中的数据量足够小，可以正常处理。然后将处理这个数据子集，并计算部分结果。然后将这个部分结果与其他 CPU 核心上从其他部分计算的其他部分结果合并。</p><p>并行化确实会带来开销。与在多个 CPU 核心上分配计算的收益相比，这种开销必须很小。否则，并行化将恶化计算性能而不是改善它们。</p><p>让我们逐一检查所有这些步骤，看看什么可能阻止你获得更好的性能提升。</p><h2 id=理解数据局部性>理解数据局部性</h2><p>数据局部性会影响数据处理的速度，无论是顺序处理还是并行处理。局部性越好，计算就越快。</p><p>为了让 CPU 可用，你的数据必须从计算机的主内存传输到 CPU 的缓存。从物理上讲，主内存是计算机的一个特定组件，与 CPU 分离。另一方面，缓存与 CPU 的核心计算元素共享同一硅片。它们通过主板和不同的通信总线连接在一起。与 CPU 核心从其缓存访问数据的速度相比，将数据从主内存传输到 CPU 缓存非常慢。</p><p>当 CPU 需要某些数据时，它首先检查这些数据是否在其缓存中可用。如果可用，则可以立即使用。如果不可用，则必须从主内存中获取这些数据并复制到缓存。这种情况称为<strong>缓存未命中</strong>。缓存未命中的代价很高，因为在此期间 CPU 正在等待数据。你希望避免这种情况。</p><p>数据在主内存和 CPU 缓存之间传输的方式在避免缓存未命中方面起着重要作用。内存按行组织。通常，一行长 64 字节，即八个 <code>long</code> 值（这可能因 CPU 而异）。主内存和 CPU 缓存之间的所有传输都是逐行进行的。因此，即使你的 CPU 只需要一个 <code>int</code> 值，包含该值的整行也会传输到缓存。</p><h3 id=迭代基本类型数组>迭代基本类型数组</h3><p>假设你的代码正在迭代一个 <code>int[]</code> 类型的数组。64 字节的一行可以容纳 16 个 <code>int</code> 值。假设访问数组的第一个元素是缓存未命中。然后 CPU 将把包含此元素的行加载到其缓存中以开始迭代。因为它加载了完整的一行，接下来的 15 个值可能也已被传输。访问下一个值将非常快。</p><p>在这种情况下，<strong>数据局部性</strong>非常好：你的数据物理上存储在主内存的连续区域中。这是可取的，因为将数据从主内存传输到 CPU 缓存会快得多。</p><h3 id=迭代-integer-实例数组>迭代 Integer 实例数组</h3><p>现在假设你的代码正在迭代一个 <code>Integer[]</code> 类型的数组。你真正拥有的不再是基本类型数组，而是引用数组。此数组的每个单元格都包含对 <code>Integer</code> 类型对象的引用，该对象可以在内存中的任何位置。</p><p>如果对数组第一个元素的访问是缓存未命中，那么 CPU 将必须将包含此元素的行加载到其缓存中。它真正加载的是数组的前 16 个引用，假设第一个引用在行的开头。然后它必须加载第一个 <code>Integer</code> 对象，该对象可能在主内存中的其他地方，导致另一个缓存未命中。实际上，读取数组的每个 <code>Integer</code> 对象很可能也会导致缓存未命中。</p><p>在这种情况下，<strong>数据局部性</strong>不如前一个示例好：对数据的引用物理上存储在主内存的连续区域中，但你进行计算所需的值不是。这是不可取的，因为将你需要的值从主内存传输到 CPU 缓存比基本类型数组的情况慢得多。</p><h3 id=迭代-integer-实例的链表>迭代 Integer 实例的链表</h3><p>让我们检查最后一种情况。现在假设你的代码正在迭代一个 <code>LinkedList&lt;Integer></code> 类型的列表。如果对第一个元素的访问是缓存未命中，那么 CPU 将把链表的第一个节点加载到其缓存中。该节点包含两个引用：第一个引用指向计算所需的值，第二个引用指向列表的下一个节点。这种情况比前一种更糟：访问列表的下一个值很可能会产生两次缓存未命中。</p><p>在这种情况下，<strong>数据局部性</strong>很糟糕：你的数据和对它们的引用都没有存储在主内存的连续区域中。访问你需要的元素将比我们检查的第一种情况慢得多。</p><h3 id=避免指针追踪>避免指针追踪</h3><p>必须跟随引用或指针来访问携带你需要的数据的正确元素称为<strong>指针追踪</strong>。指针追踪是你希望在应用程序中避免的事情，是许多性能问题的根源。迭代 <code>int</code> 值数组时不存在指针追踪。迭代 <code>Integer</code> 实例的链表时，它构成了主要的性能问题。</p><h2 id=拆分数据源>拆分数据源</h2><p>如果你决定并行处理流，第一步将包括拆分数据源。为了使拆分高效，它应该具有几个属性。</p><ul><li>拆分数据结构应该简单快速。</li><li>拆分应该均匀：你得到的两个子流应该有相同数量的数据要处理。</li></ul><h3 id=拆分-collection-实例>拆分 Collection 实例</h3><p><code>ArrayList</code> 是一个完美的拆分数据结构。你可以轻松获得中间元素，如果你按中间拆分数组，你确切地知道两个子数组中将有多少元素。</p><p>另一方面，<code>LinkedList</code> 不是一个好的拆分结构。到达中间元素需要逐个遍历列表的一半元素，这由于指针追踪而代价高昂。一旦到达那里，你可以获得具有正确元素数量的两个子列表。</p><p><code>HashSet</code> 建立在桶数组之上，因此拆分此数组与拆分数组列表的内部数组相同。但数据在此数组中的存储方式不同。更难以以保证两个部分中元素数量相同的方式拆分此数组。你甚至可能最终得到一个空的子部分。</p><p><code>TreeSet</code> 基于红黑树实现。它保证所有节点在其左右子节点上具有相同数量的元素。因此，将 <code>TreeSet</code> 实例拆分为两个均匀的子树很容易。不过，你仍然需要追踪指针来访问数据。</p><p>所有这些结构都在集合框架中使用，你可以获得它们各自携带的元素数量。</p><p>对于可以从中创建流的所有结构，情况并非如此。</p><h3 id=拆分文本文件的行>拆分文本文件的行</h3><p><code>Files.lines(path)</code> 模式就是这种情况，它在本教程前面已经介绍过。它创建一个处理此 <code>path</code> 对象表示的文本文件行的流。在不分析文本文件的情况下，无法获得文本文件的行数。</p><p><code>Pattern.splitAsStream(line)</code> 模式也是如此，我们也介绍过。它使用提供的模式从 <code>line</code> 的拆分创建流。同样，你无法预先知道在这样的流中将处理多少元素。</p><h3 id=拆分范围或生成的流>拆分范围或生成的流</h3><p>数字的特化流也为你提供了创建流的模式。</p><p><code>IntStream.range(0, 10)</code> 流很容易拆分。实际上，它看起来像一个可以按中间拆分的数字数组。每个部分中的元素数量是可预测的，这是可取的。</p><p>另一方面，<code>Stream.generate()</code> 和 <code>Stream.iterate()</code> 方法不会给你一个易于拆分的数据源。实际上，此源可能是无限的，仅受流中处理方式的限制。</p><p>让我们比较以下两种模式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> list1 <span style=color:#f92672>=</span> IntStream.<span style=color:#a6e22e>range</span>(0, 10).<span style=color:#a6e22e>boxed</span>()
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>toList</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> list2 <span style=color:#f92672>=</span> IntStream.<span style=color:#a6e22e>iterate</span>(0, i <span style=color:#f92672>-&gt;</span> i <span style=color:#f92672>+</span> 1)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>limit</span>(10).<span style=color:#a6e22e>boxed</span>()
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>toList</span>();
</span></span></code></pre></div><p>两个列表 <code>list1</code> 和 <code>list2</code> 相同，使用不同的模式创建。第一个很容易拆分，而第二个不是。主要原因是，在第二种模式中，知道第五个元素的值需要计算所有先前的元素。从这个意义上说，第二种模式看起来像一个链表，你需要访问前四个元素才能到达第五个元素。</p><h2 id=拆分和分派工作>拆分和分派工作</h2><p>一旦你的数据源被拆分，那么两个子流必须在 CPU 的不同核心上处理，并行化才能有效。</p><p>这是由 Fork/Join 框架完成的。Fork/Join 框架处理一个线程池，在应用程序启动时创建，称为公共 Fork/Join 池。此池中的线程数与 CPU 的核心数对齐。此池中的每个线程都有一个等待队列，线程可以在其中存储任务。</p><ul><li>池的第一个线程创建第一个任务。此任务的执行决定计算是否足够小可以顺序计算，还是太大应该拆分。</li><li>如果拆分，则创建两个子任务并存储在该线程的队列中。然后主任务等待两个子任务完成。在等待时，它也存储在此等待队列中。</li><li>如果进行计算，则产生结果。此结果是整个计算的部分结果。然后此任务将结果返回给创建它的主任务。</li><li>一旦任务获得了它创建的两个子任务的两个结果，它就可以合并它们以产生结果并将其返回给创建它的主任务。</li></ul><p>在某个时刻，第一个主任务从其两个子任务获得两个部分结果。然后它能够合并它们并返回计算的最终结果。</p><p>到目前为止，唯一工作的线程是池的第一个线程，它由 Fork/Join 框架调用。Fork/Join 框架实现了另一种并发编程模式，称为<strong>工作窃取</strong>。池的空闲线程可以检查同一池的其他线程的等待队列以获取任务并处理它。</p><p>这就是这种情况下发生的事情。一旦第一个等待队列中的任务数量增加，其他线程就会窃取其中一些，处理它们，进一步拆分工作，并用更多任务填充它们自己的等待队列。此功能使池的所有线程保持忙碌。</p><p>这种工作窃取功能效果很好，但它有一个缺点：根据源的拆分方式以及任务如何从一个线程移动到另一个线程，你的数据可能以任何顺序处理。在某些情况下，这可能是一个问题。</p><h2 id=处理子流>处理子流</h2><p>处理子流可能与处理完整流不同。两个元素可以使子流的处理不同：访问外部状态，以及从一个元素的处理到另一个元素携带状态。这两个元素将影响并行流的性能。</p><h3 id=访问外部状态>访问外部状态</h3><p>Fork/Join 框架将你的计算拆分为许多子任务，每个子任务由池中的线程处理。</p><p>如果你顺序处理流，所有元素都在运行方法的线程中处理。如果你并行处理同一流，元素由公共 Fork/Join 池中的线程处理。</p><p>访问流外部的状态然后从另一个线程进行，可能导致竞态条件。</p><p>让我们考虑以下代码。不幸的是，你无法在浏览器中运行此代码，你需要将其复制并粘贴到 IDE 中以查看它是如何工作的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> threadNames <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    IntStream.<span style=color:#a6e22e>range</span>(0, 100)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// .parallel()</span>
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>mapToObj</span>(index <span style=color:#f92672>-&gt;</span> Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>())
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>collect</span>(Collectors.<span style=color:#a6e22e>toSet</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>IO.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Thread names:&#34;</span>);
</span></span><span style=display:flex><span>threadNames.<span style=color:#a6e22e>forEach</span>(IO::println);
</span></span></code></pre></div><p>它产生的结果如下。</p><pre tabindex=0><code>Thread names:
main
</code></pre><p>如果你取消注释 <code>parallel()</code> 调用，那么此流将并行执行。结果变为以下内容，在你自己的机器上可能会有所不同。</p><pre tabindex=0><code>Thread names:
ForkJoinPool.commonPool-worker-3
ForkJoinPool.commonPool-worker-4
ForkJoinPool.commonPool-worker-2
ForkJoinPool.commonPool-worker-4
main
ForkJoinPool.commonPool-worker-5
</code></pre><p>对非并发外部元素的任何访问都可能导致竞态条件和数据不一致。让我们运行以下代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> ints <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>IntStream.<span style=color:#a6e22e>range</span>(0, 1_000_000)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>parallel</span>()
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>forEach</span>(ints::add);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>IO.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;ints.size() = &#34;</span> <span style=color:#f92672>+</span> ints.<span style=color:#a6e22e>size</span>());
</span></span></code></pre></div><p>多次运行此代码可能会导致不同的结果，因为公共 Fork/Join 池的所有线程都试图在 <code>ArrayList</code> 实例中并发添加数据，而 <code>ArrayList</code> 不是线程安全的结构。看到正确结果的机会很小，你甚至可能得到 <code>ArrayIndexOutOfBoundsException</code>。使用任何非并发集合或映射运行此类代码会导致不可预测的结果，包括异常。</p><p>典型的运行会给你类似这样的结果。是的，这缺失了很多元素！</p><pre tabindex=0><code>ints.size() = 387122
</code></pre><p>流修改其外部状态是一种反模式。</p><h3 id=遇到顺序>遇到顺序</h3><p>在某些情况下，Stream API 中处理数据的顺序很重要。以下方法就是这种情况。</p><ul><li><code>limit(n)</code>：将处理限制为此流的前 <code>n</code> 个元素。</li><li><code>skip(n)</code>：跳过此流的前 <code>n</code> 个元素的处理。</li><li><code>findFirst()</code>：查找流的第一个元素。</li></ul><p>这三个方法需要记住流元素的处理顺序，并需要对元素进行计数以产生正确的结果。</p><p>它们被称为<strong>有状态</strong>操作，因为它们需要携带内部状态才能工作。</p><p>在并行流中，这种有状态操作会导致开销。例如，<code>limit()</code> 需要一个内部计数器才能正确工作。在并行情况下，这个内部计数器在不同线程之间共享。在线程之间共享可变状态代价高昂，应该避免。</p><h2 id=理解并行计算流的开销>理解并行计算流的开销</h2><p>并行计算流会增加一些处理并行性的计算。这些元素有成本，你需要知道它们，以确保与并行化的好处相比，这种成本不会太高。</p><ul><li>你的数据需要拆分。拆分可以便宜，也可以昂贵，这取决于你处理的数据。数据的糟糕局部性会使拆分变得昂贵。</li><li>拆分需要高效。它需要创建均匀拆分的子流。有些源可以轻松均匀拆分，有些则不能。</li><li>一旦拆分，实现将并发处理你的数据。你应该避免访问任何外部可变状态，也应避免具有内部共享可变状态。</li><li>然后必须合并部分结果。有些结果可以轻松合并。合并整数和很容易且便宜。合并集合也很容易。合并哈希映射更昂贵。</li></ul><h2 id=陈述正确使用并行流的一些规则>陈述正确使用并行流的一些规则</h2><p><strong>规则 1</strong>：不要因为有趣而优化；因为你有要求而你没有满足它们才优化。</p><p><strong>规则 2</strong>：谨慎选择数据源。</p><p><strong>规则 3</strong>：不要修改外部状态，也不要共享可变状态。</p><p><strong>规则 4</strong>：不要猜测；测量代码的性能。</p></div><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//douglarek.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer class=content__footer></footer></section><section class=page__aside><div class=aside__content><p>2025-12-11</p><hr>On this page:<nav id=TableOfContents><ul><li><a href=#优化流计算>优化流计算</a></li><li><a href=#并行化实现>并行化实现</a></li><li><a href=#理解数据局部性>理解数据局部性</a><ul><li><a href=#迭代基本类型数组>迭代基本类型数组</a></li><li><a href=#迭代-integer-实例数组>迭代 Integer 实例数组</a></li><li><a href=#迭代-integer-实例的链表>迭代 Integer 实例的链表</a></li><li><a href=#避免指针追踪>避免指针追踪</a></li></ul></li><li><a href=#拆分数据源>拆分数据源</a><ul><li><a href=#拆分-collection-实例>拆分 Collection 实例</a></li><li><a href=#拆分文本文件的行>拆分文本文件的行</a></li><li><a href=#拆分范围或生成的流>拆分范围或生成的流</a></li></ul></li><li><a href=#拆分和分派工作>拆分和分派工作</a></li><li><a href=#处理子流>处理子流</a><ul><li><a href=#访问外部状态>访问外部状态</a></li><li><a href=#遇到顺序>遇到顺序</a></li></ul></li><li><a href=#理解并行计算流的开销>理解并行计算流的开销</a></li><li><a href=#陈述正确使用并行流的一些规则>陈述正确使用并行流的一些规则</a></li></ul></nav></div></section><footer class=page__footer><p></p><br><br><p class=copyright>Copyright © 2025 Leo Douglas</p></footer></div></body></html>
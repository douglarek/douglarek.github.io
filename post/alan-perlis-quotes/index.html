<!doctype html><html lang=zh><head><title>编程警句 by Alan J. Perlis &ndash; Code talks</title><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/palettes/base16-dark.css><link rel=stylesheet href=/css/risotto.css><link rel=stylesheet href=/css/custom.css><link rel=icon href=/favicon.ico><meta property="og:title" content="编程警句 by Alan J. Perlis &ndash; Code talks"><meta property="og:url" content="/post/alan-perlis-quotes/"><meta property="og:locale" content="zh-CN"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4TVXFV2XZM%20"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4TVXFV2XZM ")}</script></head><body><div class=page><header class=page__header><nav class="page__nav main-nav"><ul><li class=nomarker><h1 class=page__logo><a href=/ class=page__logo-inner>Code talks</a></h1></li><li class=main-nav__item><a class=nav-main-item href=/post title>Posts</a></li><li class=main-nav__item><a class=nav-main-item href=/tags title>Tags</a></li><li class=main-nav__item><a class=nav-main-item href=https://github.com/douglarek title>GitHub</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>编程警句 by Alan J. Perlis</h1><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6649330439620894" crossorigin=anonymous></script></header><div class=content__body><p>本文翻译自 <a href=https://web.archive.org/web/20230127130734/http://pu.inf.uni-tuebingen.de/users/klaeren/epigrams.html>Epigrams in Programming</a>，版权归原作者所有。</p><hr><ol><li><p><strong>One man&rsquo;s constant is another man&rsquo;s variable.</strong></p><blockquote><p>汝之常量，彼之变量。</p></blockquote></li><li><p><strong>Functions delay binding: data structures induce binding. Moral: Structure data late in the programming process.</strong></p><blockquote><p>函数延迟绑定；数据结构促成绑定。箴言：编程后期再构建数据。</p></blockquote></li><li><p><strong>Syntactic sugar causes cancer of the semi-colons.</strong></p><blockquote><p>语法糖导致了分号癌。</p></blockquote></li><li><p><strong>Every program is a part of some other program and rarely fits.</strong></p><blockquote><p>每个程序都是其他程序的一部分，而且很少能完美适配。</p></blockquote></li><li><p><strong>If a program manipulates a large amount of data, it does so in a small number of ways.</strong></p><blockquote><p>如果一个程序操作大量数据，它只会通过少数几种方式进行。</p></blockquote></li><li><p><strong>Symmetry is a complexity reducing concept (co-routines include sub-routines); seek it everywhere.</strong></p><blockquote><p>对称是降低复杂度的概念（协程包含子例程）；处处寻求对称。</p></blockquote></li><li><p><strong>It is easier to write an incorrect program than understand a correct one.</strong></p><blockquote><p>写一个不正确的程序比理解一个正确的程序更容易。</p></blockquote></li><li><p><strong>A programming language is low level when its programs require attention to the irrelevant.</strong></p><blockquote><p>当一门编程语言的程序需要关注无关紧要的细节时，它就是低级的。</p></blockquote></li><li><p><strong>It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.</strong></p><blockquote><p>100个函数操作1个数据结构，胜过10个函数操作10个数据结构。</p></blockquote></li><li><p><strong>Get into a rut early: Do the same processes the same way. Accumulate idioms. Standardize. The only difference (!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.</strong></p><blockquote><p>尽早形成套路：用同样的方式处理同样的流程。积累惯用法，并将其标准化。你与莎士比亚唯一的区别（！）在于他的惯用法列表的大小，而不是他的词汇量。</p></blockquote></li><li><p><strong>If you have a procedure with 10 parameters, you probably missed some.</strong></p><blockquote><p>如果你的一个过程有10个参数，你可能遗漏了某些。</p></blockquote></li><li><p><strong>Recursion is the root of computation since it trades description for time.</strong></p><blockquote><p>递归是计算之根，因为它用描述换取时间。</p></blockquote></li><li><p><strong>If two people write exactly the same program, each should be put in micro-code and then they certainly won&rsquo;t be the same.</strong></p><blockquote><p>如果两个人写出完全相同的程序，应该把每个人都写进微码，那样他们就肯定不一样了。</p></blockquote></li><li><p><strong>In the long run every program becomes rococo - then rubble.</strong></p><blockquote><p>从长远来看，每个程序都会变得华而不实——然后化为瓦砾。</p></blockquote></li><li><p><strong>Everything should be built top-down, except the first time.</strong></p><blockquote><p>除了第一次，一切都应该自顶向下构建。</p></blockquote></li><li><p><strong>Every program has (at least) two purposes: the one for which it was written and another for which it wasn&rsquo;t.</strong></p><blockquote><p>每个程序（至少）有两个目的：一个是它被编写出来的目的，另一个是它没被编写出来的目的。</p></blockquote></li><li><p><strong>If a listener nods his head when you&rsquo;re explaining your program, wake him up.</strong></p><blockquote><p>如果你在解释你的程序时，听众在点头，叫醒他。</p></blockquote></li><li><p><strong>A program without a loop and a structured variable isn&rsquo;t worth writing.</strong></p><blockquote><p>一个没有循环和结构化变量的程序不值得写。</p></blockquote></li><li><p><strong>A language that doesn&rsquo;t affect the way you think about programming, is not worth knowing.</strong></p><blockquote><p>一门不影响你编程思维方式的语言，不值得学习。</p></blockquote></li><li><p><strong>Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.</strong></p><blockquote><p>哪里有模块化，哪里就有误解的可能：信息隐藏意味着需要检查通信。</p></blockquote></li><li><p><strong>Optimization hinders evolution.</strong></p><blockquote><p>优化阻碍进化。</p></blockquote></li><li><p><strong>A good system can&rsquo;t have a weak command language.</strong></p><blockquote><p>一个好的系统不能有一个弱的命令语言。</p></blockquote></li><li><p><strong>To understand a program you must become both the machine and the program.</strong></p><blockquote><p>要想理解一个程序，你必须同时成为机器和程序。</p></blockquote></li><li><p><strong>Perhaps if we wrote programs from childhood on, as adults we&rsquo;d be able to read them.</strong></p><blockquote><p>也许如果我们从小就编写程序，成年后我们就能读懂它们了。</p></blockquote></li><li><p><strong>One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.</strong></p><blockquote><p>人们只能在头脑中展示复杂的信息。就像看东西一样，运动、流动或视角的改变比静态的画面更重要，无论画面多么可爱。</p></blockquote></li><li><p><strong>There will always be things we wish to say in our programs that in all known languages can only be said poorly.</strong></p><blockquote><p>在我们的程序中，总会有一些我们希望表达的东西，但在所有已知语言中都只能蹩脚地表达。</p></blockquote></li><li><p><strong>Once you understand how to write a program get someone else to write it.</strong></p><blockquote><p>一旦你明白了如何编写一个程序，就让别人去写吧。</p></blockquote></li><li><p><strong>Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?</strong></p><blockquote><p>在计算机周围，很难找到衡量进步的正确时间单位。有些大教堂花了一个世纪才完工。你能想象一个需要同样长时间的程序的宏伟和规模吗？</p></blockquote></li><li><p><strong>For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.</strong></p><blockquote><p>对于系统来说，类似于“整容”的操作是在控制图中添加一条能产生循环的边，而不仅仅是增加一个节点。</p></blockquote></li><li><p><strong>In programming, everything we do is a special case of something more general - and often we know it too quickly.</strong></p><blockquote><p>在编程中，我们所做的一切都是更普遍事物的特例——而且我们常常过快地知道这一点。</p></blockquote></li><li><p><strong>Simplicity does not precede complexity, but follows it.</strong></p><blockquote><p>简单并非先于复杂，而是随之而来。</p></blockquote></li><li><p><strong>Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.</strong></p><blockquote><p>衡量程序员的标准不是他们的聪明才智和逻辑，而是他们案例分析的完备性。</p></blockquote></li><li><p><strong>The 11th commandment was &ldquo;Thou Shalt Compute&rdquo; or &ldquo;Thou Shalt Not Compute&rdquo; - I forget which.</strong></p><blockquote><p>第十一条诫命是“你应该计算”还是“你不应该计算”——我忘了是哪个。</p></blockquote></li><li><p><strong>The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.</strong></p><blockquote><p>字符串是一种简陋的数据结构，无论它被传递到哪里，都会产生大量的重复处理。它是隐藏信息的完美载体。</p></blockquote></li><li><p><strong>Everyone can be taught to sculpt: Michelangelo would have had to be taught how not to. So it is with the great programmers.</strong></p><blockquote><p>每个人都可以被教导如何雕塑：而米开朗基罗则必须被教导如何“不”去雕塑。伟大的程序员也是如此。</p></blockquote></li><li><p><strong>The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.</strong></p><blockquote><p>使用程序来证明四色定理不会改变数学——它仅仅表明这个挑战了一个世纪的定理，可能对数学并不重要。</p></blockquote></li><li><p><strong>The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standardization of real computers would be a disaster - and so it probably won&rsquo;t happen.</strong></p><blockquote><p>最重要的计算机是我们头颅中那台狂暴的机器，它永远在寻找那个令人满意的外部模拟器。真实计算机的标准化将是一场灾难——所以它可能不会发生。</p></blockquote></li><li><p><strong>Structured Programming supports the law of the excluded muddle.</strong></p><blockquote><p>结构化编程支持“排除混乱”定律。</p></blockquote></li><li><p><strong>Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.</strong></p><blockquote><p>关于图形：一图胜过千言——但仅限于描述这幅图的那些话。几乎没有任何一组一万个词可以用图片来充分描述。</p></blockquote></li><li><p><strong>There are two ways to write error-free programs; only the third one works.</strong></p><blockquote><p>有两种方法可以编写无错误的程序；但只有第三种才有效。</p></blockquote></li><li><p><strong>Some programming languages manage to absorb change, but withstand progress.</strong></p><blockquote><p>有些编程语言能够吸收变化，但却抵制进步。</p></blockquote></li><li><p><strong>You can measure a programmer&rsquo;s perspective by noting his attitude on the continuing vitality of FORTRAN.</strong></p><blockquote><p>你可以通过观察一个程序员对FORTRAN持续生命力的态度来衡量他的视野。</p></blockquote></li><li><p><strong>In software systems it is often the early bird that makes the worm.</strong></p><blockquote><p>在软件系统中，通常是早起的鸟儿制造了虫子。</p></blockquote></li><li><p><strong>Sometimes I think the only universal in the computing field is the fetch-execute-cycle.</strong></p><blockquote><p>有时我认为计算领域唯一普遍存在的就是“取指-执行”周期。</p></blockquote></li><li><p><strong>The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.</strong></p><blockquote><p>计算的目标是模拟我们的综合能力，而不是理解我们的分析能力。</p></blockquote></li><li><p><strong>Like punning, programming is a play on words.</strong></p><blockquote><p>像双关语一样，编程是一种文字游戏。</p></blockquote></li><li><p><strong>As Will Rogers would have said, &ldquo;There is no such thing as a free variable.&rdquo;</strong></p><blockquote><p>正如威尔·罗杰斯会说的，“没有免费的变量这种东西。”</p></blockquote></li><li><p><strong>The best book on programming for the layman is &ldquo;Alice in Wonderland&rdquo;; but that&rsquo;s because it&rsquo;s the best book on anything for the layman.</strong></p><blockquote><p>对外行来说，最好的编程书籍是《爱丽丝梦游仙境》；但这是因为它本身就是写给外行的最好的书。</p></blockquote></li><li><p><strong>Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.</strong></p><blockquote><p>放弃汇编语言就像我们伊甸园里的苹果：使用浪费机器周期的语言是有罪的。LISP机器现在允许LISP程序员抛弃胸罩和遮羞布。</p></blockquote></li><li><p><strong>When we understand knowledge-based systems, it will be as before - except our finger-tips will have been singed.</strong></p><blockquote><p>当我们理解了基于知识的系统时，一切将和以前一样——除了我们的指尖会被烧焦。</p></blockquote></li><li><p><strong>Bringing computers into the home won&rsquo;t change either one, but may revitalize the corner saloon.</strong></p><blockquote><p>把电脑带回家既不会改变家庭，也不会改变电脑，但可能会让街角的酒吧重新焕发生机。</p></blockquote></li><li><p><strong>Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we&rsquo;re always starting over.</strong></p><blockquote><p>系统有子系统，子系统又有子系统，如此无限循环——这就是为什么我们总是在重新开始。</p></blockquote></li><li><p><strong>So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.</strong></p><blockquote><p>许多好主意一旦踏上语义鸿沟的航程，就再也听不到了。</p></blockquote></li><li><p><strong>Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.</strong></p><blockquote><p>小心图灵焦油坑，在里面一切皆有可能，但有趣的事情都不容易。</p></blockquote></li><li><p><strong>A LISP programmer knows the value of everything, but the cost of nothing.</strong></p><blockquote><p>LISP程序员知道一切的价值，却不知道任何东西的成本。</p></blockquote></li><li><p><strong>Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.</strong></p><blockquote><p>软件处于持续的张力之下。作为符号性的，它可以任意完善；但它也可以任意改变。</p></blockquote></li><li><p><strong>It is easier to change the specification to fit the program than vice versa.</strong></p><blockquote><p>改变需求以适应程序比反过来更容易。</p></blockquote></li><li><p><strong>Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.</strong></p><blockquote><p>傻瓜忽视复杂性。实用主义者忍受它。有些人能避免它。天才则消除它。</p></blockquote></li><li><p><strong>In English every word can be verbed. Would that it were so in our programming languages.</strong></p><blockquote><p>在英语中，每个词都可以动词化。要是我们的编程语言也能这样就好了。</p></blockquote></li><li><p><strong>Dana Scott is the Church of the Lattice-Way Saints.</strong></p><blockquote><p>丹纳·斯科特是格路圣徒教会的。</p></blockquote></li><li><p><strong>In programming, as in everything else, to be in error is to be reborn.</strong></p><blockquote><p>在编程中，就像在其他任何事情中一样，犯错就是重生。</p></blockquote></li><li><p><strong>In computing, invariants are ephemeral.</strong></p><blockquote><p>在计算中，不变量是短暂的。</p></blockquote></li><li><p><strong>When we write programs that &ldquo;learn&rdquo;, it turns out we do and they don&rsquo;t.</strong></p><blockquote><p>当我们编写“学习”的程序时，结果是我们学了，而它们没有。</p></blockquote></li><li><p><strong>Often it is means that justify ends: Goals advance technique and technique survives even when goal structures crumble.</strong></p><blockquote><p>通常是手段证明目的的正当性：目标推动技术，而技术即使在目标结构崩溃时也能幸存下来。</p></blockquote></li><li><p><strong>Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.</strong></p><blockquote><p>别搞错了：计算机处理的是数字，而不是符号。我们通过能在多大程度上将一项活动算术化的程度来衡量我们的理解（和控制）。</p></blockquote></li><li><p><strong>Making something variable is easy. Controlling duration of constancy is the trick.</strong></p><blockquote><p>让某些东西可变很容易。控制恒定期的持续时间才是诀窍。</p></blockquote></li><li><p><strong>Think of all the psychic energy expended in seeking a fundamental distinction between &ldquo;algorithm&rdquo; and &ldquo;program&rdquo;.</strong></p><blockquote><p>想想为了寻找“算法”和“程序”之间的根本区别而耗费的所有精神能量。</p></blockquote></li><li><p><strong>If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?</strong></p><blockquote><p>如果我们相信数据结构，我们就必须相信独立的（因此是并行的）处理。否则我们为什么要在一个结构中收集项目呢？为什么我们能容忍那些只给我们其一而不给其二的语言？</p></blockquote></li><li><p><strong>In a 5 year period we get one superb programming language. Only we can&rsquo;t control when the 5 year period will begin.</strong></p><blockquote><p>在一个5年周期内，我们会得到一门极好的编程语言。只是我们无法控制这个5年周期何时开始。</p></blockquote></li><li><p><strong>Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn&rsquo;t require them to carry a blackboard on their ponies.</strong></p><blockquote><p>几个世纪以来，印第安人发展了手语来交流感兴趣的现象。来自不同部落（FORTRAN、LISP、ALGOL、SNOBOL等）的程序员可以使用一种不需要他们在小马上携带黑板的语言。</p></blockquote></li><li><p><strong>Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.</strong></p><blockquote><p>文档就像定期保险：它令人满意，因为几乎没有订阅它的人依赖于它的好处。</p></blockquote></li><li><p><strong>An adequate bootstrap is a contradiction in terms.</strong></p><blockquote><p>一个“足够”的引导程序本身就是个矛盾的说法。</p></blockquote></li><li><p><strong>It is not a language&rsquo;s weaknesses but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.</strong></p><blockquote><p>控制一门语言变化梯度的不是它的弱点，而是它的优点：唉，一门语言永远无法摆脱它的胚胎囊。</p></blockquote></li><li><p><strong>It is possible that software is not like anything else, that it is meant to be discarded: that the whole point is to always see it as soap bubble?</strong></p><blockquote><p>软件可能不像其他任何东西，它注定要被丢弃：难道关键就在于永远把它看作一个肥皂泡吗？</p></blockquote></li><li><p><strong>Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.</strong></p><blockquote><p>由于其活力，计算领域总是迫切需要新的陈词滥调：平庸能抚慰我们的神经。</p></blockquote></li><li><p><strong>It is the user who should parameterize procedures, not their creators.</strong></p><blockquote><p>应该由用户来参数化过程，而不是它们的创建者。</p></blockquote></li><li><p><strong>The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.</strong></p><blockquote><p>人、计算机和算法之间的控制论交换就像一场抢椅子的游戏：疯狂地寻找平衡总是让三者之一尴尬地站着。</p></blockquote></li><li><p><strong>If your computer speaks English it was probably made in Japan.</strong></p><blockquote><p>如果你的电脑说英语，它很可能是在日本制造的。</p></blockquote></li><li><p><strong>A year spent in artificial intelligence is enough to make one believe in God.</strong></p><blockquote><p>在人工智能领域花一年时间，足以让人相信上帝的存在。</p></blockquote></li><li><p><strong>Prolonged contact with the computer turns mathematicians into clerks and vice versa.</strong></p><blockquote><p>长期接触计算机会让数学家变成文员，反之亦然。</p></blockquote></li><li><p><strong>In computing, turning the obvious into the useful is a living definition of the word &ldquo;frustration&rdquo;.</strong></p><blockquote><p>在计算中，把显而易见的东西变成有用的东西，是“挫折”这个词的活生生的定义。</p></blockquote></li><li><p><strong>We are on the verge: Today our program proved Fermat&rsquo;s next-to-last theorem!</strong></p><blockquote><p>我们正处于边缘：今天我们的程序证明了费马的倒数第二个定理！</p></blockquote></li><li><p><strong>What is the difference between a Turing machine and the modern computer? It&rsquo;s the same as that between Hillary&rsquo;s ascent of Everest and the establishment of a Hilton hotel on its peak.</strong></p><blockquote><p>图灵机和现代计算机有什么区别？这就像希拉里登上珠穆朗玛峰和在峰顶建一家希尔顿酒店的区别。</p></blockquote></li><li><p><strong>Motto for a research laboratory: What we work on today, others will first think of tomorrow.</strong></p><blockquote><p>研究室的座右铭：我们今天研究的，别人明天才会想到。</p></blockquote></li><li><p><strong>Though the Chinese should adore APL, it&rsquo;s FORTRAN they put their money on.</strong></p><blockquote><p>虽然中国人应该崇拜APL，但他们把钱押在了FORTRAN上。</p></blockquote></li><li><p><strong>We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.</strong></p><blockquote><p>如果我们认为活动数据库系统中过程与数据的比例可以任意小甚至保持很小，那我们是在自欺欺人。</p></blockquote></li><li><p><strong>We have the mini and the micro computer. In what semantic niche would the pico computer fall?</strong></p><blockquote><p>我们有迷你计算机和微型计算机。那么皮可计算机会落在哪个语义生态位呢？</p></blockquote></li><li><p><strong>It is not the computer&rsquo;s fault that Maxwell&rsquo;s equations are not adequate to design the electric motor.</strong></p><blockquote><p>麦克斯韦方程组不足以设计电动机，这不是计算机的错。</p></blockquote></li><li><p><strong>One does not learn computing by using a hand calculator, but one can forget arithmetic.</strong></p><blockquote><p>人们不会通过使用手持计算器来学习计算，但会忘记算术。</p></blockquote></li><li><p><strong>Computation has made the tree flower.</strong></p><blockquote><p>计算使树开花。</p></blockquote></li><li><p><strong>The computer reminds one of Lon Chaney - it is the machine of a thousand faces.</strong></p><blockquote><p>计算机让人想起朗·钱尼——它是一台千面机器。</p></blockquote></li><li><p><strong>The computer is the ultimate polluter. Its feces are indistinguishable from the food it produces.</strong></p><blockquote><p>计算机是终极污染者。它的排泄物与它生产的食物无法区分。</p></blockquote></li><li><p><strong>When someone says &ldquo;I want a programming language in which I need only say what I wish done,&rdquo; give him a lollipop.</strong></p><blockquote><p>当有人说“我想要一种编程语言，我只需要说出我希望做什么就行了”，给他一根棒棒糖。</p></blockquote></li><li><p><strong>Interfaces keep things tidy, but don&rsquo;t accelerate growth: Functions do.</strong></p><blockquote><p>接口保持整洁，但不能加速增长：函数可以。</p></blockquote></li><li><p><strong>Don&rsquo;t have good ideas if you aren&rsquo;t willing to be responsible for them.</strong></p><blockquote><p>如果你不愿意为好主意负责，就不要有好主意。</p></blockquote></li><li><p><strong>Computers don&rsquo;t introduce order anywhere as much as they expose opportunities.</strong></p><blockquote><p>计算机与其说是在任何地方引入秩序，不如说是在暴露机会。</p></blockquote></li><li><p><strong>When a professor insists computer science is X but not Y, have compassion for his graduate students.</strong></p><blockquote><p>当一位教授坚持认为计算机科学是X而不是Y时，请同情他的研究生。</p></blockquote></li><li><p><strong>In computing, the mean time to failure keeps getting shorter.</strong></p><blockquote><p>在计算领域，平均无故障时间越来越短。</p></blockquote></li><li><p><strong>In man-machine symbiosis, it is man who must adjust: The machines can&rsquo;t.</strong></p><blockquote><p>在人机共生中，必须调整的是人：机器不能。</p></blockquote></li><li><p><strong>We will never run out of things to program as long as there is a single program around.</strong></p><blockquote><p>只要还有一个程序存在，我们就永远不会没有东西可编。</p></blockquote></li><li><p><strong>Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You&rsquo;ve solved the wrong problem. Work hard to improve.</strong></p><blockquote><p>处理失败很容易：努力改进。处理成功也很容易：你解决了错误的问题。努力改进。</p></blockquote></li><li><p><strong>One can&rsquo;t proceed from the informal to the formal by formal means.</strong></p><blockquote><p>人们无法通过形式化的手段从非形式化走向形式化。</p></blockquote></li><li><p><strong>Purely applicative languages are poorly applicable.</strong></p><blockquote><p>纯应用型语言的适用性很差。</p></blockquote></li><li><p><strong>The proof of a system&rsquo;s value is its existence.</strong></p><blockquote><p>一个系统价值的证明就是它的存在。</p></blockquote></li><li><p><strong>You can&rsquo;t communicate complexity, only an awareness of it.</strong></p><blockquote><p>你无法传达复杂性，只能传达对它的意识。</p></blockquote></li><li><p><strong>It&rsquo;s difficult to extract sense from strings, but they&rsquo;re the only communication coin we can count on.</strong></p><blockquote><p>从字符串中提取意义很困难，但它们是我们唯一可以依赖的交流货币。</p></blockquote></li><li><p><strong>The debate rages on: Is PL/I Bactrian or Dromedary?</strong></p><blockquote><p>辩论仍在继续：PL/I是双峰驼还是单峰驼？</p></blockquote></li><li><p><strong>Whenever two programmers meet to criticize their programs, both are silent.</strong></p><blockquote><p>每当两个程序员见面批评他们的程序时，两人都沉默不语。</p></blockquote></li><li><p><strong>Think of it! With VLSI we can pack 100 ENIACs in 1 sq.cm.</strong></p><blockquote><p>想想看！通过VLSI，我们可以在1平方厘米内封装100个ENIAC。</p></blockquote></li><li><p><strong>Editing is a rewording activity.</strong></p><blockquote><p>编辑是一种改写活动。</p></blockquote></li><li><p><strong>Why did the Roman Empire collapse? What is the Latin for office automation?</strong></p><blockquote><p>罗马帝国为什么会崩溃？办公自动化的拉丁语是什么？</p></blockquote></li><li><p><strong>Computer Science is embarrassed by the computer.</strong></p><blockquote><p>计算机科学为计算机感到尴尬。</p></blockquote></li><li><p><strong>The only constructive theory connecting neuroscience and psychology will arise from the study of software.</strong></p><blockquote><p>唯一连接神经科学和心理学的建设性理论将来自对软件的研究。</p></blockquote></li><li><p><strong>Within a computer natural language is unnatural.</strong></p><blockquote><p>在计算机内部，自然语言是不自然的。</p></blockquote></li><li><p><strong>Most people find the concept of programming obvious, but the doing impossible.</strong></p><blockquote><p>大多数人觉得编程的概念显而易见，但实践起来却不可能。</p></blockquote></li><li><p><strong>You think you know when you learn, are more sure when you can write, even more when you can teach, but certain when you can program.</strong></p><blockquote><p>当你学习时，你以为你知道了；当你能写作时，你更确定了；当你能教书时，你更加确定；但当你能编程时，你就确信无疑了。</p></blockquote></li><li><p><strong>It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?</strong></p><blockquote><p>教孩子们编程与现代教育的理念背道而驰。制定计划、培养组织思想的纪律、关注细节和学会自我批评有什么乐趣呢？</p></blockquote></li><li><p><strong>If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.</strong></p><blockquote><p>如果你能想象一个计算机机器人是唯一仆人的社会，你就能想象任何事情。</p></blockquote></li><li><p><strong>Programming is an unnatural act.</strong></p><blockquote><p>编程是一种不自然的行为。</p></blockquote></li><li><p><strong>Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.</strong></p><blockquote><p>使旧程序适应新机器通常意味着使新机器表现得像旧机器。</p></blockquote></li><li><p><strong>In seeking the unattainable, simplicity only gets in the way.</strong></p><blockquote><p>在追求遥不可及的目标时，简单只会碍事。</p></blockquote></li></ol><hr><ol start=122><li><p><strong>If there are epigrams, there must be meta-epigrams.</strong></p><blockquote><p>如果有警句，就一定有元警句。</p></blockquote></li><li><p><strong>Epigrams are interfaces across which appreciation and insight flow.</strong></p><blockquote><p>警句是欣赏和洞察力流动的接口。</p></blockquote></li><li><p><strong>Epigrams parameterize auras.</strong></p><blockquote><p>警句参数化气场。</p></blockquote></li><li><p><strong>Epigrams are macros, since they are executed at read time.</strong></p><blockquote><p>警句是宏，因为它们在阅读时执行。</p></blockquote></li><li><p><strong>Epigrams crystallize incongruities.</strong></p><blockquote><p>警句使不协调之处结晶。</p></blockquote></li><li><p><strong>Epigrams retrieve deep semantics from a data base that is all procedure.</strong></p><blockquote><p>警句从一个全是过程的数据库中检索深层语义。</p></blockquote></li><li><p><strong>Epigrams scorn detail and make a point: They are a superb high-level documentation.</strong></p><blockquote><p>警句蔑视细节，直击要点：它们是极好的高级文档。</p></blockquote></li><li><p><strong>Epigrams are more like vitamins than protein.</strong></p><blockquote><p>警句更像维生素而不是蛋白质。</p></blockquote></li><li><p><strong>The last epigram? Neither eat nor drink them, snuff epigrams.</strong></p><blockquote><p>最后一句警句？不要吃也不要喝，去品味警句。</p></blockquote></li></ol></div><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//douglarek.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer class=content__footer></footer></section><section class=page__aside><div class=aside__content><p>2025-07-07</p><hr>On this page:<nav id=TableOfContents></nav></div></section><footer class=page__footer><p></p><br><br><p class=copyright>Copyright © 2025 Leo Douglas</p></footer></div></body></html>
<!doctype html><html lang=zh><head><title>为什么 Go 不实现分代和紧凑 gc &ndash; Code talks</title><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/palettes/base16-dark.css><link rel=stylesheet href=/css/risotto.css><link rel=stylesheet href=/css/custom.css><link rel=icon href=/favicon.ico><meta property="og:title" content="为什么 Go 不实现分代和紧凑 gc &ndash; Code talks"><meta property="og:url" content="/post/why-golang-garbage-collector-not-implement-generational-and-compact-gc/"><meta property="og:locale" content="zh-CN"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4TVXFV2XZM%20"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4TVXFV2XZM ")}</script></head><body><div class=page><header class=page__header><nav class="page__nav main-nav"><ul><li class=nomarker><h1 class=page__logo><a href=/ class=page__logo-inner>Code talks</a></h1></li><li class=main-nav__item><a class=nav-main-item href=/post title>Posts</a></li><li class=main-nav__item><a class=nav-main-item href=/tags title>Tags</a></li><li class=main-nav__item><a class=nav-main-item href=https://github.com/douglarek title>GitHub</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>为什么 Go 不实现分代和紧凑 gc</h1><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6649330439620894" crossorigin=anonymous></script></header><div class=content__body><p>本文翻译自 <a href=https://groups.google.com/forum/#!msg/golang-nuts/KJiyv2mV2pU/wdBUH1mHCAAJ>golang-nuts</a>，版权归原作者所有。</p><p>有人在论坛里面问: 为什么 Golang 垃圾回收器不实现分代和紧凑 gc ?</p><p>Ian Lance Taylor 的回复:</p><p>这已经在过去讨论过了.</p><p>忽略细节, 紧凑(compacting) GC 的基本优点是:</p><ul><li>避免碎片, 以及;</li><li>允许使用简单而有效的凹凸分配器(bump allocator).</li></ul><p>但是, 现代的内存分配算法, 象 Go 运行时使用的基于 tcmalloc 的方案基本上没有碎片问题. 而凹凸分配器对于 Go 这样需要锁的多线程程序中的单线程程序是简单有效的. 一般来说, 这可能更多有效地使用一组每个线程缓存来分配内存, 而在这一点上你已经失去了凹凸分配器的优势. 所以我会断言, 一般来说有很多注意事项导致今天没有真正的优势为一个多线程程序使用压缩内存分配器. 我不是说使用压缩分配器有什么问题, 我只是认为它相对于非压缩的来说没有带来任何大的优势.</p><p>现在我们来考虑一下分代 GC. 分代 GC 的关键依赖于世代的假设: 分配在一个程序中的大部分值很快变得不会用到, 所以分代 GC 有一个优势就是可以花更多的时间查看最近分配的对象. 这里 Go 不同于许多垃圾收集语言, 因为许多对象是直接在程序栈(stack)上分配的. Go 编译器使用逃逸分析(escape analysis)来查找那些在编译时生命周期就已知的对象, 将它们分配到堆栈而不是垃圾收集的内存中. 所以一般来说, 在 Go 中, 与其他语言相比, 有很大比例的分代 GC 要找的很快不会用到的(quickly-unused)值不会分配在 GC 内存的首要位置. 所以分代 GC 能给 Go 带来的优势相对于其他语言要小.</p><p>更微妙的是, 大多数世代 GC 实现的隐藏点是减少垃圾收集带来的程序暂停的时间. 暂停期间只看最年轻的一代, 暂停时间很短. 然而, Go 使用了一个并发垃圾收集器, 并且在 Go 中程序暂停时间与年轻代或者任意代的大小无关. Go 基本上假设, 在多线程程序中, 通过在不同的核上并行运行 GC, 不是为了最小化 GC 时间去暂停导致程序运行更长的时间, 而是总体上花更多的总 CPU 时间在 GC 上.</p><p>总之, 分代 GC 可能仍然可以为 Go 带来显著的价值, 即减少并行 GC 时的工作量. 这是一个需要测试的假设. Go 当前的 GC 工作实际上正在密切关注一个相关但不同的假设: Go 程序可能倾向于按请求分配内存. <a href=https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/view>这里</a>有一个描述. 这项工作正在进行中, 现实情况是否有利还有待观察.</p></div><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//douglarek.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer class=content__footer></footer></section><section class=page__aside><div class=aside__content><p>2018-01-13</p><hr>On this page:<nav id=TableOfContents></nav></div></section><footer class=page__footer><p></p><br><br><p class=copyright>Copyright © 2025 Leo Douglas</p></footer></div></body></html>
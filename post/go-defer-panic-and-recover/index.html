<!doctype html><html lang=zh><head><title>理解 Go defer, panic, recover &ndash; Code talks</title><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/palettes/base16-dark.css><link rel=stylesheet href=/css/risotto.css><link rel=stylesheet href=/css/custom.css><link rel=icon href=/favicon.ico><meta property="og:title" content="理解 Go defer, panic, recover &ndash; Code talks"><meta property="og:url" content="/post/go-defer-panic-and-recover/"><meta property="og:locale" content="zh-CN"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4TVXFV2XZM%20"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4TVXFV2XZM ")}</script></head><body><div class=page><header class=page__header><nav class="page__nav main-nav"><ul><li class=nomarker><h1 class=page__logo><a href=/ class=page__logo-inner>Code talks</a></h1></li><li class=main-nav__item><a class=nav-main-item href=/post title>Posts</a></li><li class=main-nav__item><a class=nav-main-item href=/tags title>Tags</a></li><li class=main-nav__item><a class=nav-main-item href=https://github.com/douglarek title>GitHub</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>理解 Go defer, panic, recover</h1><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6649330439620894" crossorigin=anonymous></script></header><div class=content__body><p>不像 Go 的其他流程控制(if, for, switch, goto, go) 一样, defer, panic 和 recover 用的比较少.</p><h2 id=defer>Defer</h2><p>defer 语句会将函数调用放入一个列表. 当外围的函数执行返回后列表内保存的函数调用会被执行. defer 像 Python 的 with, finally 一样都具有类似资源情理的作用. 当然 defer 在这方面更灵活.</p><p>defer 的行为遵循 3 个简单的原则:</p><ul><li><p>一个 defer 函数的参数在放入待调用列表的时候被立即求值. 比如:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>a</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>) <span style=color:#75715e>// @1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个例子中, @1 中的 i 会被立即求值, 所以 a 函数调用返回时, 会打印出 &ldquo;0&rdquo; 而不是 &ldquo;1&rdquo;.</p></li><li><p>defer 函数在外围函数返回时遵循 <strong>先进后出</strong> 的调用顺序.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>b</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>4</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Print</span>(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>b 函数将会打印出 &ldquo;3210&rdquo;.</p></li><li><p>defer 函数会读取并且赋值外围函数的命名返回值(named return values).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>c</span>() (<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> }()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个例子中 i 的值会 在 defer 被调用时执行加 1 操作, 所以 c 将返回 2. 这对于修改一个函数的 error 返回值很方便.</p></li></ul><h2 id=panic>Panic</h2><p>panic 是一个内置的函数用来阻断一般的控制流程. Go spec 对于 panic 有一段<a href=https://golang.org/ref/spec#Handling_panics>描述</a>:</p><blockquote><p>当执行函数 F 时, 一个明确的 panic 调用或者<a href=https://golang.org/ref/spec#Run_time_panics>运行时 panic</a>(数组越界访问等)会终止 F 的执行. F 所属的任何 defer 函数继续执行. 紧接着, 任何 F 调用者的 defer 函数运行, 而且对于执行中的 goroutine 中的任何顶层 defer 函数也是如此. 到那时, 程序终止并且报错(错误包含在 panic 参数中). 该终止序列被称为 <strong>panicking</strong>.</p></blockquote><h2 id=recover>Recover</h2><p>recover 是一个内建函数用来恢复一个 panicking 的 goroutine. Go spec 对于 recover 有一段<a href=https://golang.org/ref/spec#Handling_panics>描述</a>:</p><blockquote><p>设想有一个函数 G, 有一个 defer 函数会调用 recover 并且和 G 在同一 goroutine 的函数发生了 panic. 当运行到 defer 函数 D 调用的时候, D 调用 recover 的返回值是 panic 调用时传入的值. 如果 D 正常返回, 没有开启一个新的 panic, panicking 序列会终止. 在这种情况下, G 和 panic 之间的函数调用状态被废弃, 并且正常的调用恢复. 然后 G 中任何在 D 之前的 defer 函数会执行, 并且 G 的执行通过返回到它的调用者而终止.</p></blockquote><p>以下情况中 recover 的返回值为 nil:</p><ul><li>panic 参数为 nil;</li><li>当前 goroutine 没有发生 panicking;</li><li>recover 没有被一个 defer 函数直接调用.</li></ul><p>以下示例程序演示了 panic 和 defer 的原理:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>f</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Returned normally from f.&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> recover(); <span style=color:#a6e22e>r</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Recovered in f&#34;</span>, <span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Calling g.&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>g</span>(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Returned normally from g.&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>g</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &gt; <span style=color:#ae81ff>3</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Panicking!&#34;</span>)
</span></span><span style=display:flex><span>        panic(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%v&#34;</span>, <span style=color:#a6e22e>i</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Defer in g&#34;</span>, <span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Printing in g&#34;</span>, <span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>g</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>函数返回:</p><pre tabindex=0><code>Calling g.
Printing in g 0
Printing in g 1
Printing in g 2
Printing in g 3
Panicking!
Defer in g 3
Defer in g 2
Defer in g 1
Defer in g 0
Recovered in f 4
Returned normally from f.
</code></pre><p>如果我们移除 f 中 defer 将输出:</p><pre tabindex=0><code>Calling g.
Printing in g 0
Printing in g 1
Printing in g 2
Printing in g 3
Panicking!
Defer in g 3
Defer in g 2
Defer in g 1
Defer in g 0
panic: 4

panic PC=0x2a9cd8
[stack trace omitted]
</code></pre><p><em>Go 标准库中的约定是</em>, 即使一个包在内部使用 panic, 其外部 API 仍会给出明确的错误返回值(真实的例子可以参见标准库 <a href=http://golang.org/src/pkg/encoding/json/decode.go>json 包</a>). 这是很好的使用原则, 尤其当我们写自己库的时候, 难免需要处理来自第三方的包返回的各种 error, 如果不需要处理, 简单的一个 panic 会是很好的方案.</p><h2 id=结束>结束</h2><p>到这里可能就是你所能看到的关于 defer, panic 和 recover 的所有"坑"(我一向不觉得文档中有的你没看到的东西叫坑). 下面的内容可以不看了, 但是你看了, 保证没坏处.</p><p>当然可能有人说 recover 不能恢复所有的 panic, 比如如下的程序:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> recover(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;recovered&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>v</span>] = <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果运行该程序, 那么会得到如下的输出:</p><pre tabindex=0><code>fatal error: concurrent map writes
fatal error: concurrent map writes
...
</code></pre><p><em>其实这个不叫 panic</em>, 按官方文档的说法叫: 崩溃(crash) 和 内存腐败(memory corruption). 由于程序无视 <a href=https://golang.org/ref/mem/>Go 内存模型</a> 而导致的数据竞争(data race).</p><p>当然对于以上程序来说, 运行程序崩溃是显而易见的, 然而有的程序运行时不会显式的的崩溃, 如:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>m</span>[<span style=color:#e6db74>&#34;1&#34;</span>] = <span style=color:#e6db74>&#34;a&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span>[<span style=color:#e6db74>&#34;2&#34;</span>] = <span style=color:#e6db74>&#34;b&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>m</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出:</p><pre tabindex=0><code>2 b
1 a
</code></pre><p>为了检测和预防这种崩溃, Go 内建了数据竞争探测器(data race detector), 可以通过传递 flag: -race 给 go 命令来启用:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ go test -race mypkg
</span></span><span style=display:flex><span>$ go run -race mysrc.go
</span></span><span style=display:flex><span>$ go build -race mycmd
</span></span><span style=display:flex><span>$ go install -race mypkg
</span></span></code></pre></div><p>我们再次对上面的程序使用命令: go run -race main.go, 那么数据探测器可以检测到:</p><pre tabindex=0><code>==================
WARNING: DATA RACE
Write at 0x00c420090180 by goroutine 6:
  runtime.mapassign_faststr()
      /usr/local/Cellar/go/1.10/libexec/src/runtime/hashmap_fast.go:694 +0x0
  main.main.func1()
      /Users/a/.go/src/github.com/gorocks/snippets/go/cmd/gosnippets/main.go:9 +0x5d

Previous write at 0x00c420090180 by main goroutine:
  runtime.mapassign_faststr()
      /usr/local/Cellar/go/1.10/libexec/src/runtime/hashmap_fast.go:694 +0x0
  main.main()
      /Users/a/.go/src/github.com/gorocks/snippets/go/cmd/gosnippets/main.go:12 +0xc9

Goroutine 6 (running) created at:
  main.main()
      /Users/a/.go/src/github.com/gorocks/snippets/go/cmd/gosnippets/main.go:8 +0x9a
==================
1 a
2 b
Found 1 data race(s)
exit status 66
</code></pre><h2 id=参考资料>参考资料</h2><ul><li><a href=https://blog.golang.org/defer-panic-and-recover>Defer, Panic, and Recover</a></li><li><a href=https://golang.org/ref/spec>Go spec</a></li><li><a href=https://golang.org/ref/mem/>The Go Memory Model</a></li><li><a href=https://golang.org/doc/articles/race_detector.html>Data Race Detector</a></li></ul></div><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//douglarek.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer class=content__footer></footer></section><section class=page__aside><div class=aside__content><p>2018-03-23</p><hr>On this page:<nav id=TableOfContents><ul><li><a href=#defer>Defer</a></li><li><a href=#panic>Panic</a></li><li><a href=#recover>Recover</a></li><li><a href=#结束>结束</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></section><footer class=page__footer><p></p><br><br><p class=copyright>Copyright © 2025 Leo Douglas</p></footer></div></body></html>
<!doctype html><html lang=zh><head><title>Go Range 循环内幕 &ndash; Code talks</title><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/css/palettes/base16-dark.css><link rel=stylesheet href=/css/risotto.css><link rel=stylesheet href=/css/custom.css><link rel=icon href=/favicon.ico><meta property="og:title" content="Go Range 循环内幕 &ndash; Code talks"><meta property="og:url" content="/post/go-range-loop-internals/"><meta property="og:locale" content="zh-CN"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4TVXFV2XZM%20"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4TVXFV2XZM ")}</script></head><body><div class=page><header class=page__header><nav class="page__nav main-nav"><ul><li class=nomarker><h1 class=page__logo><a href=/ class=page__logo-inner>Code talks</a></h1></li><li class=main-nav__item><a class=nav-main-item href=/post title>Posts</a></li><li class=main-nav__item><a class=nav-main-item href=/tags title>Tags</a></li><li class=main-nav__item><a class=nav-main-item href=https://github.com/douglarek title>GitHub</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>Go Range 循环内幕</h1><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6649330439620894" crossorigin=anonymous></script></header><div class=content__body><p>本文翻译自 <a href=https://garbagecollected.org/2017/02/22/go-range-loop-internals/>Go Range Loop Internals</a>，版权归原作者所有。</p><p>虽然他们非常方便, 但我总是发现 Go 的 Range 循环有点神秘. 我并不是第一个:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// http://bit.ly/2CXC1Ob 来自 Dave Cheney.</span>
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>v</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>v</span> = append(<span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在我可以把这些事实记录下来, 但是我很可能会忘记. 为了有更好的机会记住这个, 我需要找出为什么 range 循环会这样. 所以我写了这篇文章.</p><h2 id=step-1-读手册rtfm>Step 1: 读手册(RTFM)</h2><p>我们首先应该去读 range 循环文档. Go语言规范文档在 <a href=https://golang.org/ref/spec#For_statements>for 语句</a>部分的 <em>For 语句和 range 子句</em>描述了 range 循环. 我不会在这里复制整个规范，我会总结一些有趣的部分.</p><p>首先, 让我们提醒自己我们在这里看到什么:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>a</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=range-变量>Range 变量</h2><p>你们中的大多数人会知道, 在 Range 子句的左边(上面的例子中的 i), 你可以这样分配循环变量:</p><ul><li>分配 (=)</li><li>短变量声明 (:=)</li></ul><p>您也可以选择完全忽略循环变量.</p><p>如果使用短变量声明样式分配(:=), 则 Go 将在循环的每个迭代中重用变量(仅在循环内的范围内).</p><h2 id=range-表达式>Range 表达式</h2><p>在 Range 子句的右边(上面的例子中的 a), 你可以找到他们称之为 Range 表达式的东西. 它可以包含任何表达式, 其计算结果如下:</p><ul><li>数组(array)</li><li>指向数组的指针</li><li>切片(slice)</li><li>字符串(string)</li><li>字典(map)</li><li>允许接收的管道(channel), 如: chan int 或者 chan&lt;- int</li></ul><p><strong>Range 表达式在开始循环之前只计算一次</strong>. 请注意, 这个规则有一个例外: 如果 Range 一个数组(或指向它的指针), 你只能分配索引：那么只有 len(a) 被计算. 仅计算 len(a) 意味着可以在编译时计算表达式 a, 并由编译器用常量替换. <a href=https://golang.org/ref/spec#Length_and_capacity>len 函数规范</a>解释如下:</p><blockquote><p>如果s的类型是数组或指向数组的指针并且表达式 s 不包含通道接收(channel receives) 或(非 常量) 函数调用, 则表达式 len(s) 和 cap(s) 是常量. 在这种情况下 s 不被计算. 否则, len 和 cap 的调用不是常量, 而是被计算.</p></blockquote><p>那么 &ldquo;计算(evaluated)&rdquo; 究竟意味着什么呢? 不幸的是我不能在规范中找到这个信息. 当然, 我可以猜测, 这意味着完全执行表达式, 直到它不能进一步减少. 在任何情况下, 这里的高位是 Range 表达式在循环开始之前计算一次. 你如何只评估一个表达式仅一次? 通过将其分配给一个变量! 这可能是这里发生的事情吗?</p><p>有趣的是, 这个规范提到了一些关于从 map 中添加和删除的特殊的东西(没有提到切片):</p><blockquote><p>如果在迭代过程中移除尚未到达的 map 项, 则不会生成相应的迭代值. 如果迭代过程中创建 map 项, 那么可能会在迭代过程中生成该项, 或者可能会跳过该项.</p></blockquote><p>我稍后会回到 map.</p><h2 id=step-2-range-支持的数据类型>Step 2: Range 支持的数据类型</h2><p>如果我们假设 Range 表达式在循环开始之前被赋值了一次, 那么这是什么意思? 答案是它取决于数据类型, 所以让我们仔细看一下 Range 所支持的数据类型.</p><p>在我们这样做之前, 请记住这一点: <strong>在 Go 中, 您分配的所有东西都被复制</strong>. 如果您分配一个指针, 则复制指针.如果你分配一个结构体, 则复制结构.将参数传递给函数时也是如此. 无论如何, 这里是:</p><p>// TODO</p><p>请参阅本文底部的参考资料, 了解更多关于这些数据类型的内部结构.</p><p>那么这是什么意思? 这些例子突出了一些差异:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// copies the entire array</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> [<span style=color:#ae81ff>10</span>]<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>acopy</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// copies the slice header struct only, NOT the backing array</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>scopy</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// copies the map pointer only</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>mcopy</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>
</span></span></code></pre></div><p>所以如果在一个 Range 循环的开始处, 你可以将一个数组表达式赋值给一个变量(以确保它只能计算一次), 那么你将复制整个数组.</p><h2 id=step-3-go-编译器源码>Step 3: Go 编译器源码</h2><p>(未完待续)</p></div><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//douglarek.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer class=content__footer></footer></section><section class=page__aside><div class=aside__content><p>2018-01-10</p><hr>On this page:<nav id=TableOfContents><ul><li><a href=#step-1-读手册rtfm>Step 1: 读手册(RTFM)</a></li><li><a href=#range-变量>Range 变量</a></li><li><a href=#range-表达式>Range 表达式</a></li><li><a href=#step-2-range-支持的数据类型>Step 2: Range 支持的数据类型</a></li><li><a href=#step-3-go-编译器源码>Step 3: Go 编译器源码</a></li></ul></nav></div></section><footer class=page__footer><p></p><br><br><p class=copyright>Copyright © 2025 Leo Douglas</p></footer></div></body></html>